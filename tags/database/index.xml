<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database on www.mirkosertic.de</title>
    <link>https://www.mirkosertic.de/tags/database/</link>
    <description>Recent content in Database on www.mirkosertic.de</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Mirko Sertic</copyright>
    <lastBuildDate>Wed, 07 Apr 2021 12:27:46 +0200</lastBuildDate>
    <atom:link href="https://www.mirkosertic.de/tags/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Self-Contained-Systems Light &amp; Shadow</title>
      <link>https://www.mirkosertic.de/blog/2021/04/scs-light-and-shadow/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0200</pubDate>
      <guid>https://www.mirkosertic.de/blog/2021/04/scs-light-and-shadow/</guid>
      <description>Self-Contained-Cystem, what is it? Self-Contained-System, referred to the following short SCS, is an architectural approach. The idea is to map requirements using individual, functionally independent systems. These systems include everything for mapping the necessary requirements, starting with data management, the actual business logic and finally a complete user interface. This makes these systems self-contained.&#xA;Each SCS should be looked after by its own development team. In addition to the technical separation of the systems, this architectural approach should also facilitate the organizational separation.</description>
    </item>
    <item>
      <title>An overview of current NoSQL databases</title>
      <link>https://www.mirkosertic.de/blog/2012/11/an-overview-of-current-nosql-databases/</link>
      <pubDate>Thu, 22 Nov 2012 03:37:03 +0100</pubDate>
      <guid>https://www.mirkosertic.de/blog/2012/11/an-overview-of-current-nosql-databases/</guid>
      <description>This summary is taken from the book “Seven Databases in Seven Weeks”. See the Books section for details.&#xA;Database&#xA;Version&#xA;Genre&#xA;Data Types&#xA;Data Relations&#xA;Standard Object&#xA;Written in&#xA;Transactions&#xA;Triggers&#xA;Main Differentiator&#xA;Weaknesses&#xA;MongoDB&#xA;2.0&#xA;Document&#xA;Typed&#xA;None&#xA;JSON&#xA;C++&#xA;No&#xA;No&#xA;Easily query Big Data&#xA;Embed-ability&#xA;CouchDB&#xA;1.1&#xA;Document&#xA;Typed&#xA;None&#xA;JSON&#xA;Erlang&#xA;No&#xA;Update validation or Changes API&#xA;Durable and embeddable clusters&#xA;Query-ability&#xA;Riak&#xA;1.0&#xA;Key-value</description>
    </item>
    <item>
      <title>Reusing domain objects to create query specifications</title>
      <link>https://www.mirkosertic.de/blog/2012/07/reusing-domain-objects-to-create-query-specifications/</link>
      <pubDate>Fri, 20 Jul 2012 02:18:59 +0200</pubDate>
      <guid>https://www.mirkosertic.de/blog/2012/07/reusing-domain-objects-to-create-query-specifications/</guid>
      <description>Problem Often you need to create query specifications to retrieve data from persistent memory. One of the following patterns is most likely used:&#xA;Bind Entity or Service with a distinct Query Object to the repository. A Service creates a distinct query object, passes it to the repository. Here the query object is translated to a Hibernate or JPA Criteria or HQL Statement and finally executed against the database.&#xA;Pros:</description>
    </item>
  </channel>
</rss>
