<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Building a Smart Roomba: A Symphony of Hardware and ROS &middot; Mirko Sertic</title><meta name="description" content="Take a deep dive into transforming a Roomba into an intelligent cleaning machine using a Raspberry Pi Zero 2 W and the Robot Operating System (ROS)! This comprehensive architecture breakdown reveals how open-source magic turns simple hardware into a sophisticated robot, combining LiDAR, IMU sensors, and clever software layers for autonomous navigation."><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="robots" content="index,follow"><meta property="og:title" content="Building a Smart Roomba: A Symphony of Hardware and ROS"><meta property="og:description" content="Take a deep dive into transforming a Roomba into an intelligent cleaning machine using a Raspberry Pi Zero 2 W and the Robot Operating System (ROS)! This comprehensive architecture breakdown reveals how open-source magic turns simple hardware into a sophisticated robot, combining LiDAR, IMU sensors, and clever software layers for autonomous navigation."><meta property="og:type" content="article"><meta property="og:url" content="https://www.mirkosertic.de/blog/2022/10/roomba-series-1/"><meta name="viewport" content="width=device-width,initial-scale=1"><link href="https://www.mirkosertic.de/css/site.css" rel="stylesheet" media="screen"><link rel="shortcut icon" type="image/x-icon" href="https://www.mirkosertic.de/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="https://www.mirkosertic.de/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://www.mirkosertic.de/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://www.mirkosertic.de/favicon-16x16.png"><link rel="manifest" href="https://www.mirkosertic.de/manifest.json"><link rel="mask-icon" href="https://www.mirkosertic.de/safari-pinned-tab.svg" color="#5bbad5"><meta name="theme-color" content="#ffffff"></head><body itemscope itemtype="http://schema.org/WebPage"><header><nav class="navbar navbar-expand-md navbar-dark fixed-top" itemscope itemtype="http://www.schema.org/SiteNavigationElement"><div class="container"><a class="navbar-brand" href="https://www.mirkosertic.de/">www.mirkosertic.de</a> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarCollapse"><ul class="navbar-nav mr-auto"><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/toolsgoodies" title="My personal Technology Radar">Technology Radar</a></li><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/interestingbooks" title="Interesting Books">Interesting Books</a></li><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/favorites" title="My favorite postings">My favorite postings</a></li><li class="nav-item"><a itemprop="url" class="nav-link active" href="/post/" title="Blog">Blog</a></li></ul></div></div></nav></header><main role="main"><div itemprop="mainEntity" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header"><div class="contentbox"><h1 class="post-title" itemprop="name headline">Building a Smart Roomba: A Symphony of Hardware and ROS</h1><p class="post-date"><span class="icon"><i class="fa fa-calendar-check-o-white"></i></span><time datetime="2022-10-13" itemprop="datePublished">Thu, Oct 13, 2022</time> <span>by</span> <span itemprop="author" itemscope="" itemtype="https://schema.org/Person"><span itemprop="name"><a href="https://x.com/mirkosertic" itemprop="url" rel="author">Mirko Sertic</a></span></span></p><p class="post-abstract" itemprop="abstract"><span>This article presents a detailed exploration of a custom Roomba vacuum system architecture, built using a Raspberry Pi Zero 2 W and the Robot Operating System (ROS). The system integrates various sensors including YDLiDAR X4, MPU6050 IMU, and HMC5883L magnetometer, organized in a layered architecture comprising hardware interface, localization, navigation, high-level functions, and supervisor layers. Each layer serves specific functions, from basic hardware communication to complex autonomous navigation and cleaning path planning, demonstrating how open-source components can be combined to create a sophisticated robotic system.</span></p><p><span class="icon"><i class="fa fa-clock-white"></i></span><span>7 Minutes reading time</span></p><p class="post-tags"><span class="tag"><span class="icon"><i class="fa fa-tags-white"></i></span><a href="/tags/roomba">Roomba</a> ,<a href="/tags/robot">Robot</a> ,<a href="/tags/diy">DIY</a> ,<a href="/tags/architecture">Architecture</a></span></p></div></header><article class="post-content clearfix" itemprop="articleBody"><div class="sect1"><h2 id="_standing_on_the_shoulders_of_giants">Standing on the shoulders of giants</h2><div class="sectionbody"><div class="paragraph"><p>My custom Roomba vacuum uses a lot of free available open source software. Without it, it wouldn’t be possible to create and compose a complex system such as an autonomous robot in a reasonable amount of time.</p></div><div class="paragraph"><p>The core ingredients are:</p></div><div class="ulist"><ul><li><p>Raspberry Pi Zero 2 W</p></li><li><p>Ubuntu 64bit OS</p></li><li><p>Additional sensors, connected by USB, UART or I2C bus.</p></li><li><p>Robot Operating System (ROS), Noetic Release</p></li></ul></div><div class="paragraph"><p>The Raspberry Pi 2W is the brain of the system. This brain runs an Ubuntu 64bit operating system. There are additional sensors connected to the Pi such as the Roomba itself using UART and the Roomba Open Interface, a YDLiDAR X4 using USB and a MPU6050 IMU and a small OLED display using the I2C bus. This is more or less the whole hardware layer of the system.</p></div><div class="paragraph"><p>On top of the hardware layer runs the software layer. Heart of this layer is the ROS, the Robot Operating System. It is an open-source robotics middleware suite. It is not a real operating system, but a set of software frameworks for robot software development. It provides services such as hardware abstraction, low-level device control, implementation of commonly used functionality, message-passing between processes, and package management.</p></div><div class="paragraph"><p>The ROS components are controlled by project-specific parts, such as the web-based user interface, system supervision and implementation of the navigation and cleaning functionality. Measured in lines-of-code, the project-specific part is tiny compared to the out-of-the-box functionality of the ROS suite. It is truly standing on the shoulders of giants.</p></div></div></div><div class="sect1"><h2 id="_the_roomba_layered_architecture">The Roomba layered Architecture</h2><div class="sectionbody"><div class="paragraph"><p>The following diagrams shows the whole hardware wiring of the described components. There is really no magic involved.</p></div><div class="imageblock kroki"><div class="content"><img src="/media/roombahardware-3da67ae1c845cff4bb4aa28d6d79236762fee68e.svg" alt="roombahardware"></div></div><div class="paragraph"><p>The Roomba only has a serial interface, which can be connected to the Raspberry Pi’s serial interface. However, we have to keep in mind the different signal levels, so I am using a bidirectional level shifter between them. The level shifter is not part of the diagram.</p></div><div class="paragraph"><p>The YDLiDAR X4 also has a serial interface. However, it comes with a serial-to-usb adapter, and the whole software suite including the ROS driver fits to this adapter. I wanted to reuse as much as possible, so I used the serial-to-usb adapter and connected the LiDAR with USB to the Raspberry. In the future I also might use a multi-uart-to-i2c adapter, and connect everything using the I2C bus. But I didn’t have time to check this out yet.</p></div><div class="paragraph"><p>The MPU6050 IMU, the HMC5883L magnetometer and the OLED displays are directly connected to the I2C bus of the Raspberry.</p></div><div class="paragraph"><p>Now comes the interesting part. How is the Roomba software organized? First, I’ll show you a diagram, and I’ll explain it later:</p></div><div class="imageblock kroki"><div class="content"><img src="/media/roombalayers-c37c2ae92fdc1ed196febb7e2957b146215fef78.svg" alt="roombalayers"></div></div><div class="paragraph"><p>This is a very simplistic overview of the whole system. The key building block is the concept of a ROS node. Nodes are processes doing stuff. Nodes can communicate with other nodes by calling provided services or consuming or publishing messages over topics. I didn’t include the relevant topics in the overview to make it simpler for the beginning.</p></div><div class="paragraph"><p>Let’s start from bottom to top:</p></div><div class="sect2"><h3 id="_hardware_interface_layer">Hardware interface layer</h3><div class="paragraph"><p>The hardware interface layer is responsible to communicate with the physical hardware.</p></div><div class="imageblock kroki"><div class="content"><img src="/media/roombahardwareinterfacelayer-1cdd5768c0b027f4d2b3b0c565ec2e342de0348b.svg" alt="roombahardwareinterfacelayer"></div></div><div class="paragraph"><p>The <strong>roombainterface</strong> node reads the Roomba sensor data stream such as wheel encoders or bumpers and publishes the data over topics. It also consumes messages controlling the actuators such as the left or right wheel or the vacuum. This node is Roomba specific.</p></div><div class="paragraph"><p>The <strong>imu</strong> node reads data from the MPU6050 IMU and publishes the data over topics. The nature of this data is noisy. This node is Roomba specific.</p></div><div class="paragraph"><p>The <strong>differentialodometry</strong> node reads the Roomba sensor messages and converts data from the wheel encoders to a robot odometry including a pose. A pose includes a position, and orientation and additional velocity and acceleration information. All of this is derived from the wheel encoder data. The nature of this data is noisy and it will drift over time a lot. This node is Roomba specific.</p></div><div class="paragraph"><p>The <strong>ydlidar</strong> node reads data from the YDLiDAR X4 360 degrees laser scanner and publishes the data over topics. The nature of this data is noisy, but it is the only source of absolute measurements in this stack. We can measure the absolute distance to a wall with a laser scan. All other sensors can only track relative movements and acceleration. This node is provided by the LiDAR manufacturer.</p></div><div class="paragraph"><p>The <strong>ekf_localization_node</strong> node does sensor fusion. As mentioned above, the IMU and odometry data are noisy, and tend to drift over time. The ekf_localization_node node uses an Extended Kalman filter to create and continuously refine a position estimation based on the noisy sensor data. This should remove drift and increase precision of the measured position, acceleration and velocity. This node is part of the ROS stack.</p></div></div><div class="sect2"><h3 id="_localization_layer">Localization layer</h3><div class="paragraph"><p>The localization layer creates a precise localization of the Roomba on a map based on absolute(LiDAR) and relative (fused odometry) data.</p></div><div class="imageblock kroki"><div class="content"><img src="/media/roombalocalizationlayer-cfd8d0d0b4183720775ffe1afdd58efa692bb262.svg" alt="roombalocalizationlayer"></div></div><div class="paragraph"><p>The <strong>gmapping</strong> node provides a SLAM(Simultaneous Localization and Mapping) implementation. It consumes LiDAR and odometry data and continuously builds a map and a position of the Roomba on the map. This map and position is refined over time as new sensor data arrives. The Roomba stack uses the gmapping node as long as there is no stored map of a known room to clean available. This node is part of the ROS stack.</p></div><div class="paragraph"><p>The <strong>mapserver</strong> node is used when the Roomba is started in a known room. It reads a stored map from disk and provides the map data to the ROS stack. This node is part of the ROS stack.</p></div><div class="paragraph"><p>The <strong>amcl</strong> node is used with a stored map from the <strong>mapserver</strong> node. It uses a particle filter to find the robot position on a given map based on odometry and LiDAR data. However, it cannot refine or change a stored map. This node is part of the ROS stack.</p></div><div class="paragraph"><p>Either the gmapping or mapserver+amcl nodes are started by the supervisor, depending on the requested operational mode.</p></div></div><div class="sect2"><h3 id="_navigation_layer">Navigation layer</h3><div class="paragraph"><p>The navigation stack can guide a robot from one place of the map to another place. It reads sensor data and positional information and creates steering commands for the robot to reach a target pose.</p></div><div class="imageblock kroki"><div class="content"><img src="/media/roombanavigationlayer-541f9f0be3bb5371b98882e6832530cff320a869.svg" alt="roombanavigationlayer"></div></div><div class="paragraph"><p>The <strong>move_base</strong> node is part of the ROS navigation stack and also part of the ROS suite. It consumes map data and positional information and can compute plans to reach a given target pose on the map. It consumes sensor information such as LiDAR or bumper data to add additional information to the provided map. This information is stored as cost maps, which can be either static (the map itself) or volatile (temporal obstacles, detected by LiDAR or bumper data). The computed plan is continuously refined. Move_base can also cancel the computed plan once it detects that the target pose is no longer reachable. This node is part of the ROS stack.</p></div></div><div class="sect2"><h3 id="_high_level_functions_layer">High level functions layer</h3><div class="paragraph"><p>The high level functions layer implements the cleaning functionality. It can compute a full coverage path for the Roomba based on a map and instructs the navigation layer the follow that path.</p></div><div class="imageblock kroki"><div class="content"><img src="/media/roombahighlevelfunctionslayer-c252f122095c10e7c92f850492ad6c6048ac726d.svg" alt="roombahighlevelfunctionslayer"></div></div><div class="paragraph"><p>The <strong>highlevel</strong> node implements the whole functionality. It uses the map data to create a minimum spanning tree from the grid cells. The cleaning path is derived from this spanning tree. It also implements recovery mechanisms once the navigation layer detects a part of the path is no longer reachable. The highlevel node also actively decides when to activate or deactivate the vacuum actuators. This node is Roomba specific.</p></div></div><div class="sect2"><h3 id="_supervisor_functions_layer">Supervisor functions layer</h3><div class="paragraph"><p>The supervisor functions layer provides the web-based user interface. It is always active, and starts and stops on demand all other layers of the system.</p></div><div class="imageblock kroki"><div class="content"><img src="/media/supervisorlayer-f3c24f752a81df7444546f42a4fea8bd5179c31f.svg" alt="supervisorlayer"></div></div><div class="paragraph"><p>The <strong>supervisor</strong> node implements the user interface. Once a user decides to clean a room, the supervisor starts all other layers of the stack and controls their lifecycle. It provides visual feedback such as the map, the current robot position, the already cleaned path and so on. It also uses the OLED display to render telemetry and status data directly on the device. This node is Roomba specific.</p></div></div></div></div><div class="sect1"><h2 id="_thats_it">That’s it</h2><div class="sectionbody"><div class="paragraph"><p>Here we are. Now you’ve got the first overview of the whole Roomba ROS hardware and software stack. If you like to dived deeper into the whole system, please take a look at the source code provided at <a href="https://github.com/mirkosertic/roomba500">the GitHub project page</a>. Stay tuned for the next post of the Roomba Series. Thank you for reading!</p></div></div></div><div class="metainfo"><span>&lt;&lt;Pevious posting: <a href="https://www.mirkosertic.de/blog/2022/02/roomba-series/">DIY Robot Revolution: Transforming an Old Roomba into a Smart Autonomous System</a></span> <span>Next posting: <a href="https://www.mirkosertic.de/blog/2023/01/magnetometer-calibration-ellipsoid/">Transform Wonky Magnetometer Data into Perfect Circles: A Python Guide</a>&gt;&gt;</span></div><p><i class="fa fa-github"></i>Git revision: <a href="https://github.com/mirkosertic/www_mirkosertic_de/commit/2e692ad1fff282e93d9fa3fdd726190d7e7afd82" target="_blank">2e692ad</a></p></article></div></main><footer><p>&copy; Mirko Sertic &middot; <a href="https://www.mirkosertic.de/global/impressum/index.html">Imprint / Impressum</a></p><address><strong itemprop="name">Mirko Sertic</strong><div itemprop="address" itemscope itemtype="http://schema.org/PostalAddress"><div itemprop="streetAddress">Josefine-Mauser-Str. 66</div><div itemprop="postalCode">48157 Münster</div><div itemprop="addressCountry">Germany</div></div><a class="icon" target="_top" href="mailto:mirko@mirkosertic.de"><i class="fa fa-envelope-white"></i></a> <a class="icon" target="_blank" href="https://x.com/mirkosertic" itemprop="url"><i class="fa fa-x-twitter-white"></i></a> <a class="icon" target="_blank" href="https://github.com/mirkosertic" itemprop="url"><i class="fa fa-github-white"></i></a> <a class="icon" target="_blank" href="https://de.linkedin.com/in/mirko-sertic-98882397" itemprop="url"><i class="fa fa-linkedin-white"></i></a></address><p class="float-right"><a href="#">Back to top</a></p></footer><script src="https://www.mirkosertic.de/js/bootstrap-native-v4.min.js"></script><script>function existsByCSSSelector(aSelector) {
        var element = document.querySelector(aSelector);
        if (element) {
            return true;
        }
        return false;
    }

    var Loader = function () { };
    Loader.prototype = {
        require: function (scripts, callback) {
            this.loadCount = 0;
            this.totalRequired = scripts.length;
            this.callback = callback;

            for (var i=0;i<scripts.length;i++) {
                this.writeScript(scripts[i]);
            }
        },
        loaded: function (evt) {
            this.loadCount++;

            if (this.loadCount==this.totalRequired && typeof this.callback=='function') this.callback.call();
        },
        writeScript: function (src) {
            var self = this;
            var s = document.createElement('script');
            s.type = "text/javascript";
            s.async = true;
            s.src = src;
            s.addEventListener('load', function (e) { self.loaded(e); }, false);
            var head = document.getElementsByTagName('head')[0];
            head.appendChild(s);
        }
    };

    if (existsByCSSSelector("pre.highlight code") > 0) {
        var loader = new Loader();
        loader.require(["https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"], function() {

            var additionalStylesheet = document.createElement('link');
            additionalStylesheet.rel = "stylesheet";
            additionalStylesheet.type = 'text/css';
            additionalStylesheet.media = "screen";
            additionalStylesheet.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css";

            var head = document.getElementsByTagName('head')[0];
            head.appendChild(additionalStylesheet);

            hljs.highlightAll();
        });
    }</script></body></html>