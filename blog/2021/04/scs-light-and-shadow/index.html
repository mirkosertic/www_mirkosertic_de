<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Self-Contained-Systems Light &amp; Shadow &middot; Mirko Sertic</title><meta name="description" content="Self-Contained-System is an interesting organizational and architectural approach. In the following article I would like to elaborate on the ideas behind this approach and provide food for thought for its efficient implementation. In addition, I would like to shed light on possible stumbling blocks, because where there is light there is also shadow."><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="robots" content="index,follow"><meta property="og:title" content="Self-Contained-Systems Light &amp; Shadow"><meta property="og:description" content="Self-Contained-System is an interesting organizational and architectural approach. In the following article I would like to elaborate on the ideas behind this approach and provide food for thought for its efficient implementation. In addition, I would like to shed light on possible stumbling blocks, because where there is light there is also shadow."><meta property="og:type" content="article"><meta property="og:url" content="https://www.mirkosertic.de/blog/2021/04/scs-light-and-shadow/"><meta name="viewport" content="width=device-width,initial-scale=1"><link href="https://www.mirkosertic.de/css/site.css" rel="stylesheet" media="screen"><link rel="shortcut icon" type="image/x-icon" href="https://www.mirkosertic.de/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="https://www.mirkosertic.de/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://www.mirkosertic.de/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://www.mirkosertic.de/favicon-16x16.png"><link rel="manifest" href="https://www.mirkosertic.de/manifest.json"><link rel="mask-icon" href="https://www.mirkosertic.de/safari-pinned-tab.svg" color="#5bbad5"><script src="https://polyfill.io/v2/polyfill.min.js?features=default,IntersectionObserver"></script><meta name="theme-color" content="#ffffff"><script>var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-33614060-2', 'auto');
	
	ga('send', 'pageview');
}</script><script async src="https://www.google-analytics.com/analytics.js"></script></head><body itemscope itemtype="http://schema.org/WebPage"><header><nav class="navbar navbar-expand-md navbar-dark fixed-top" itemscope itemtype="http://www.schema.org/SiteNavigationElement"><div class="container"><a class="navbar-brand" href="https://www.mirkosertic.de/">www.mirkosertic.de</a> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarCollapse"><ul class="navbar-nav mr-auto"><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/toolsgoodies" title="Tools &amp; Goodies">Tools &amp; Goodies</a></li><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/interestingbooks" title="Interesting Books">Interesting Books</a></li><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/favorites" title="My favorite postings">My favorite postings</a></li><li class="nav-item"><a itemprop="url" class="nav-link active" href="/post/" title="Blog">Blog</a></li></ul></div></div></nav></header><main role="main"><div itemprop="mainEntity" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header"><h1 class="post-title" itemprop="name headline">Self-Contained-Systems Light &amp; Shadow</h1><p class="post-date"><span class="icon"><i class="fa fa-calendar-check-o-white"></i></span><time datetime="2021-04-07" itemprop="datePublished">Wed, Apr 7, 2021</time> <span>by</span> <span itemprop="author" itemscope="" itemtype="https://schema.org/Person"><span itemprop="name"><a href="https://twitter.com/mirkosertic" itemprop="url" rel="author">Mirko Sertic</a></span></span></p><p><span class="icon"><i class="fa fa-clock-white"></i></span><span>17 Minutes reading time</span></p><p class="post-tags"><span class="tag"><span class="icon"><i class="fa fa-tags-white"></i></span><a href="/tags/database">Database</a></span> ,&nbsp;<a href="/tags/enterprise">Enterprise</a> ,&nbsp;<a href="/tags/web">Web</a> ,&nbsp;<a href="/tags/domain-driven-design">Domain-driven Design</a></p></header><article class="post-content clearfix" itemprop="articleBody"><div class="sect1"><h2 id="_self_contained_cystem_what_is_it">Self-Contained-Cystem, what is it?</h2><div class="sectionbody"><div class="paragraph"><p>Self-Contained-System, referred to the following short SCS, is an architectural approach. The idea is to map requirements using individual, functionally independent systems. These systems include everything for mapping the necessary requirements, starting with data management, the actual business logic and finally a complete user interface. This makes these systems self-contained.</p></div><div class="paragraph"><p>Each SCS should be looked after by its own development team. In addition to the technical separation of the systems, this architectural approach should also facilitate the organizational separation. By avoiding dependencies, the teams also become more independent and therefore more flexible.</p></div><div class="paragraph"><p>That’s the theory. In the following paragraphs I would like to address the advantages and also possible problems when implementing the SCS approach.</p></div></div></div><div class="sect1"><h2 id="_important_basics">Important basics</h2><div class="sectionbody"><div class="paragraph"><p>The idea of defining functionally independent systems is not new. Eric Evans has coined the term Domain-driven Design, short DDD. DDD clearly focuses on the technical requirements and the resulting technical structure. DDD offers design patterns to document and to implement the technical requirements. In the DDD world is a professionally enclosed area a Bounded-Context.</p></div><div class="paragraph"><p>The SCS approach is based precisely on these Bounded-Contexts and expands its definition. In addition to the technical logic, the user interface is also implemented in this context. An important point here is that when a functionality is called, there should be no synchronous communication with components outside the SCS. If communication takes place, it should only take place asynchronously.</p></div><div class="paragraph"><p>This has several consequences. It makes the system more resistant to possible errors such as timeouts. The implementation of the logic is also simpler, since no patterns, such as a bulk head or a circuit breaker, are switched upstream of the communication and any fallback scenarios have to be implemented. The other consequence is the prevention of the further breakdown of the Bounded-Context into further artifacts, an approach which is also often called &#34;microservices&#34;. Why now this? In the DDD world a Bounded-Context is a unit which encapsulates all the necessary logic. When a change is made to this unit, such as a database extension, this change will probably apply to more than just the database and covers all &#34;layers&#34; of Bounded-Context. Now, if these layers are not distributed across &#34;Micro Services&#34; the scope of such changes is easier to overlook and it might not result into the need of introducing breaking changes to external APIs.</p></div><div class="paragraph"><p>The explicit denial of synchronous communication is also intended to reduce the risk of building a distributed monolith with far too many and slow interfaces. So the motto is: less is more. Or to put it more pragmatically: what is not there does not make mistakes.</p></div></div></div><div class="sect1"><h2 id="_a_few_words_about_the_organization">A few words about the organization</h2><div class="sectionbody"><div class="paragraph"><p>The SCS architecture approach has consequences for the organization and the team structure. As already mentioned in the introduction, each SCS should be looked after by a responsible team. This means that the team needs all necessary skills to do so. These competencies would be, for example, product ownership, development and QA competencies and also Ops or UX. By bundling these competencies in a team, the team becomes capable of acting and can pick up speed in the implementation of new features. So ideally every team member is in the &#34;full stack&#34;.</p></div><div class="paragraph"><p>Architecture decisions affecting only one SCS are called Micro-Architecture decisions. These decisions can be made and revised quickly as the scope is limited to an SCS. There are local decisions, such as which Java version, which framework, whether a hexagonal structure is used or which persistence API is used.</p></div><div class="paragraph"><p>This contrasts with Macro-Architecture decisions. These decisions affect the entire system landscape, usually have a wider scope, require more coordination effort and are usually more difficult to revise. Such decisions are, for example, the number of SCSs, which cross-system protocols are to be used or which standards for the presentation technology are to be complied with. Macro-Architecture is therefore also and mainly organizational architecture!</p></div><div class="paragraph"><p>How big can an SCS and the supervising team get? That is a very interesting question and there is no absolute answer to it. One team should oversee one SCS, possibly several, depending on the technical structure and the resulting complexity. The driving factor behind the team size is therefore exclusively the professional scope.</p></div><div class="paragraph"><p>In SCS so it is not just a collection of technical principles, but rather a guideline for organizing development teams. Without adjustments within the organization, the approach cannot show its advantages. Ideally, this corresponds to the organization of the Context-map from the DDD world.</p></div></div></div><div class="sect1"><h2 id="_data_storage">Data storage</h2><div class="sectionbody"><div class="paragraph"><p>An SCS should contain all functionalities that are necessary for the execution of the use cases it contains. This also includes the data required for this. This poses a number of challenges at the data storage level. An &#34; order management &#34; SCS probably needs the data for the orders and also has data sovereignty over this data. It probably also needs the customer data, but may not have data sovereignty over this data. It uses this data, is dependent on it, but does not manage it. How can this problem be implemented?</p></div><div class="paragraph"><p>The answer is: data replication.</p></div><div class="paragraph"><p>With data replication, the technical replication of the data is meant, and not the technical replication, as would be possible with a master-slave database setup, for example. What’s the difference here? Replication on a technical level, i.e. via DB replication, would reveal too many implementation details and tie the systems together too tightly. Changes to the database schema no longer only affect one SCS. Technical and organizational dependencies would arise, and this is exactly what the SCS approach is supposed to prevent.</p></div><div class="paragraph"><p>Another argument is that not all systems need a full copy of the data, and they probably need to access the data differently. Certain data may also not be allowed to leave the original system, as they are particularly in need of protection. For example, system A can also be optimized for write access to customer data, and system B can only be optimized for read access. This then results in other requirements for the database to be used, the database schema, forms of normalization, etc.</p></div><div class="paragraph"><p>What are the options now? Event sourcing in conjunction with a transaction log has proven to work well. A change to a customer data record in the &#34; customer management &#34; SCS would generate the event &#34;customer was changed&#34; with the new customer data and write it to a transaction log. The &#34; order management &#34; SCS would consume this event from the transaction log, extract the data necessary for order management and write to its own database.</p></div><div class="paragraph"><p>Solutions like Apache Kafka are very interesting as a transaction log. In addition to the fact that this is pull solution and that the complexity at the Kafka server level can be kept very small, another aspect is much more important. Kafka enables a journey through time! The consumer of events can reset his &#34;offset&#34; within the transaction log in order to process events from the past again. This functionality is important for a disaster recovery!</p></div><div class="paragraph"><p>Errors can and will happen, be it technical problems or just bugs in the software. Through the time travel we can install a new version of the software, consume events from the past and repair any broken data sets afterwards. A functionality that turned out to be very useful!</p></div><div class="paragraph"><p>A disadvantage of this data replication is the resulting redundancy and the associated space consumption. If, for example, several million item data records are replicated across multiple systems, the size should not be underestimated and can also be a cost driver. The license model of the database must also be taken into account from a cost perspective. Each SCS should get its own database server, for example, during maintenance work on a database server, this maintenance does not have an effect on multiple systems. Licensing costs can explode. Here it is important to weigh up the risks, advantages and disadvantages and to find a pragmatic solution, which is also documented and communicated.</p></div><div class="paragraph"><p>When it comes to data replication, the issue of data protection must not be neglected. Where can customer data be stored? What about credit card details? What options for auditing must be provided? Which data must be subsequently erasable? Which data must be anonymized, possibly also afterwards? Does this only affect the target system or also the transaction log in between? What about GDPR compliance? Are there any additional requirements? The responsible data protection officer must be consulted in any case, because technical data replication can very quickly result in a technical and legal problem.</p></div></div></div><div class="sect1"><h2 id="_the_most_important_thing_the_business_logic">The most important thing, the business logic</h2><div class="sectionbody"><div class="paragraph"><p>When implementing the business logic, there are a few things to consider from a conceptual point of view. SCS build on a core of approaches from Domain-Driven design. Domain-driven Design also helps in the implementation of the business logic. Patterns such as aggregate, entity, value object and repository help to structure and implement the business logic well. A hexagonal architecture further supports these patterns and helps to obtain a modular and easily testable system structure. Time to learn and deepen your knowledge about Domain-driven Design is never wasted!</p></div><div class="paragraph"><p>Problems arise with the implementation of use cases that cannot be completely implemented within an SCS because, for example, suppliers or business partners are involved. We stay with the example of the &#34; Order Management &#34; SCS and look at the application, &#34;Buy and stock reserve four items&#34; more closely. When a customer orders something, the order should be booked in the system. Depending on whether the item is still in stock or not, the stock should be reserved for the customer or a reorder should be initiated. The result of the processing should be displayed to the customer.</p></div><div class="paragraph"><p>This use case has it all!</p></div><div class="paragraph"><p>Posting an order in the system is easy to implement. The reservation of stocks and the reordering are interesting. The warehouse management is probably from another SCS is responsible, just as the re-ordering. Communication should take place asynchronously in order to decouple the systems. Nevertheless, the result of the processing should be displayed to the customer after the order has been received. What options do we have? From the point of view of design patterns, the SAGA pattern is interesting. The SAGA pattern is intended to help implement distributed transactions. In addition to the technical implementation of the pattern, the technical requirements must also be implemented, such as calling up warehouse management and re-ordering including error handling! From a technical point of view, this is already challenging enough. In this case, error handling in particular is driven more from a technical than a technical point of view. What happens, for example, if the call to warehouse management takes too long? What happens if an error occurs while reordering? Should the system try again? How do I stop processing completely? And how do I get the whole thing meaningfully integrated into the SCS?</p></div><div class="paragraph"><p>One possible solution here is to use a lightweight workflow engine, which in the &#34;Order Management&#34; SCS embedded is. A Workflow-Engine brings with the technical structure necessary for the correct implementation of the SAGA patterns. The workflow definition can very well with those in charge are coordinated and transparent. The focus on the implementation of the business logic is not lost. Embedded workflow engines have another advantage: as a rule, the workflow definition forms a unit with the SCS. A change in one usually also affects the other. It therefore makes sense to version, package and also deploy them together.</p></div><div class="paragraph"><p>In this context, is still said that the call of another system should not be a synchronous call, as cross-system communication should be asynchronously. The call is the sending of an event to the target system and waiting for a corresponding response event from the target system including timeout handling, etc. Workflow engines are particularly helpful when it comes to modeling and implementing such functionalities!</p></div><div class="paragraph"><p>We coukd implement the &#34;Buy and inventory reserve&#34; usecase like this: When you click on the &#34;Buy&#34; button inside the &#34; Order Management &#34; SCS the corresponding workflow on the workflow engine is started. If this workflow runs through successfully within a few dozen milliseconds, the order management can respond to the customer with the corresponding status of the order. If the workflow does not go through completely, we can also inform the customer of this with a corresponding note, and then later notify him of the processing via e-mail or push notification. This mechanism helps to implement the application correctly to scale better peak loads on systems and also helps to implement user-friendly error handling.</p></div><div class="paragraph"><p>I already advertised Apache Kafka, now I also advertise a workflow-engine. An interesting and very lightweight solution is for example Zeebe from Camunda.</p></div><div class="paragraph"><p>Business logic should be encapsulated in an SCS. However, this does not mean that Java, for example, has to be used to implement all use cases. Especially with data-intense applications, it may be useful to rely on SQL instead of ORM frameworks like JPA to use. The use of SQL does not subvert the encapsulation, it just brings business logic and data closer together. This is an example of the microarchitecture that is locally restricted to an SCS. These architecture and design decisions should be made by the responsible SCS team.</p></div></div></div><div class="sect1"><h2 id="_the_user_interface">The user interface</h2><div class="sectionbody"><div class="paragraph"><p>Each SCS should contain the complete user interface for the use cases it contains. Ideally, it is a web application, i.e. the user interface is HTML, CSS and JavaScript.</p></div><div class="paragraph"><p>Whole books can be written on this subject alone. In connection with SCS, however, special attention must be paid to the integration of several SCS into a uniform user interface.</p></div><div class="paragraph"><p>As a user, I would like to use different functionalities. These functionalities should lead to the responsible SCS via &#34;Link&#34;. Taking any online shop as an example, the question arises as to where, for example, the top navigation that is displayed on almost every page comes from. Should this functionality be implemented redundantly in several SCS?</p></div><div class="paragraph"><p>The answer is of course: no.</p></div><div class="paragraph"><p>There is a system that is responsible for top navigation. Another system is responsible for calculating recommendations, for example, and another system can, for example, generate article lists based on filter criteria. Each of these systems delivers an &#34;HTML snippet&#34; for precisely this part of the page.</p></div><div class="paragraph"><p>The individual page components must be combined into one unit. There are several options here. One possibility would be to use a content management system that does the aggregation. This option is the most powerful, but it also raises the organizational question of who is in charge of and further developing this system. In addition, new dependencies between competent teams emerge and not least a single point of failure for the whole architecture. Another, somewhat lighter weight option is to integrate the page layout and placeholders for non-system content into the SCS in the form of templates. These placeholders could be SSI directives (server-side includes) or ESI directives (edge-side includes). The resolution of these placeholders would then be carried out by an upstream web server or varnish cache. In practice, I would rather recommend a lightweight solution and expand it later if this is really necessary. Once it has been brought into production, it is difficult to reduce complexity.</p></div><div class="paragraph"><p>When it comes to ESI or caching, details need to be taken into account when it comes to personalized content. We want to achieve the highest possible cache hit rate. However, personalized content is usually very difficult to cache. One solution is to always display the same basic HTML structure for all users and to reload the personalized content via JavaScript. This strategy also makes sense without a cache in the background. In connection with Progressive-Enhancement interesting possibilities arise. Why, for example, deliver content when it is not even visible on the target device because the screen is too small? Why want to view videos when the target device can’t? All of these questions can only be answered on the target device and not on the application server. The server only delivers the basic structure of the page via semantic HTML. The rest is decided and assembled on the target device.</p></div><div class="paragraph"><p>How do we get a uniform user experience? Is there a central repository for styles? What happens to JavaScript code? Every SCS has the styles and the JavaScript in the abdomen. The trick is to drive componebt-based approach in connection with a modularization of stylesheets and the JavaScript. A component is, for example, the top navigation or an article list. Each component has the necessary HTML, CSS and JavaScript. There should be as little global styles are defined as possible. This is the only way to implement functionalities independently and within an SCS and ultimately to build speed in development and short time-to-market. Here it is important to find a pragmatic way.</p></div><div class="paragraph"><p>The consequence is that there is no longer a global stylesheet for everything. This is intentional, but from UX’s point of view it is a nightmare as a first reaction. However, if we take a closer look at large online shops such as Amazon, we also find that the page layout in the item lists is completely different than in the checkout. Probably because these pages are served by a different system. This has never bothered me as a customer, but as a computer scientist I notice it. Presumably, a pragmatic decision was made here between a uniform layout, independence from systems and teams, and development time and development costs.</p></div><div class="paragraph"><p>This chapter is very HTML l knotty. In fact, HTML is basically the choice for the presentation layer when implementing an SCS. It becomes problematic when mixed presentation technologies have to be used. This is particularly the case when certain use cases are to be made available via app. If the app is a hybrid app and a WebView is already integrated, HTML can be used. However, if the app should use the native capabilities of the end device or be completely offline-capable, a different interface must be made available for the app. In this case, the SCS approach reaches its limit, as the user interface is no longer part of the SCS, and probably also the app development is no longer part of the actual SCS team. In this case, the compromise would be to add a (REST) API to the SCS and make this available to the app. The functionality then remains encapsulated in the SCS, only the app-specific part of the presentation layer is externalized.</p></div></div></div><div class="sect1"><h2 id="_lessons_learned">Lessons learned</h2><div class="sectionbody"><div class="paragraph"><p>A lot more can be written about SCS as an architecture and organizational approach. Nevertheless, I would like to draw a line and this article with a short lessons learned here to complete.</p></div><div class="paragraph"><p>SCS can help organize and structure the work of larger development teams. But also for smaller projects and teams it may be an interesting approach that the focus clearly on requirements without distracting on technical implementation details.</p></div><div class="paragraph"><p>The principles behind Domain-driven Design find are wonderful application here. The principle, less is more, is also reflected in the current trends of software development and the return to a few, but important and correct &#34;Services&#34;. As with all architectural decisions, this is not a matter of choosing between black and white. There is always a trade-off between advantages and disadvantages and life with the associated consequences.</p></div><div class="paragraph"><p>Which framework and which programming language are the best to implement an SCS? In my opinion, they are all equally suitable as long as the technical requirements can be implemented with them and, of course, the development team can work productively and sustainably with them. The SCS approach should help to use the most sensible technology for each SCS. In practice, a compromise has to be found between innovative approaches and technological growth.</p></div><div class="paragraph"><p>The core concepts from the SCS architecture can also be transferred to Swing or JavaFX applications. This approach is not popular, but it is possible. Desktop applications still have their authorization. An interesting combination from my professional past is Swing and Canoo UltraLightClient, ULC for short. ULC is essentially server-side Swing with a presentation layer that is distributed via WebStart. This example is a bit older, as the technology stack suggests. We didn’t call it SCS at the time either, but the approach was similar. If I wanted to get angry, I would say SCS can also be implemented with the Java portlet specification and a good, old J2EE application server. My point: with a little creativity, the concepts can also be profitable to something unfamiliar areas and also outside the Java world applied. Basically they are timeless and have only been rediscovered by SCS.</p></div><div class="paragraph"><p>My experiences with the SCS architecture approach are positive. My only criticism is that the SCS &#34;Manifesto&#34; is coarse grained and ironically too many details are left open. The point “Macro-Architecture” in particular could provide more details and information, as this is exactly where the factors for a successful implementation are hidden. I hope this article has shed a little light on the darkness.</p></div><div class="paragraph"><p>With this in mind, I would like to thank you for your attention. I am of course available for questions, comments and criticism. Many Thanks!</p></div><div class="paragraph"><p>Links / Sources / References:</p></div><div class="paragraph"><p>Self-contained systems - <a href="https://scs-architecture.org/" class="bare">https://scs-architecture.org/</a></p></div><div class="paragraph"><p>Evans, Eric : Domain-driven Design: Tackling Complexity in the Heart of Software</p></div><div class="paragraph"><p>Apache Kafka - <a href="https://kafka.apache.org/" class="bare">https://kafka.apache.org/</a></p></div><div class="paragraph"><p>SAGA Pattern - <a href="https://de.wikipedia.org/wiki/Saga_(Draft" class="bare">https://de.wikipedia.org/wiki/Saga_(Draft</a> pattern )</p></div><div class="paragraph"><p>Zeebe - <a href="https://zeebe.io/" class="bare">https://zeebe.io/</a></p></div><div class="paragraph"><p>Canoo ULC - <a href="https://de.wikipedia.org/wiki/UltraLightClient" class="bare">https://de.wikipedia.org/wiki/UltraLightClient</a></p></div></div></div><div class="metainfo"><span>&lt;&lt;Pevious posting: <a href="https://www.mirkosertic.de/blog/2019/04/java-desktop-packaging/">Packaging JavaFX Applications for the Desktop</a></span> <span>Next posting: <a href="https://www.mirkosertic.de/blog/2021/08/swing-jetbrains-projector/">Running Swing Applications with JetBrains Projector in a browser</a>&gt;&gt;</span></div><p><i class="fa fa-github"></i>Git revision: <a href="https://github.com/mirkosertic/www_mirkosertic_de/commit/b5b51260ca9deda6d018d3cec36f390d59d44ab7" target="_blank">b5b5126</a></p></article></div><div class="comments"><div id="disqus-placeholder">Loading comments...</div><div id="disqus_thread"></div><script>'use strict';
        window.addEventListener("load", function(event) {
            var disqusLoaded = false;
            var disqusObserver = new IntersectionObserver(function(entries, observer) {
                entries.forEach(function(entry) {
                    if (!disqusLoaded && entry.isIntersecting) {
                        console.log("Loading Disqus");
                        disqusLoaded = true;

                        document.getElementById('disqus-placeholder').remove();

                        
                        var script = document.createElement('script');
                        script.src = '//www-mirkosertic-de.disqus.com/embed.js';
                        script.async = true;
                        script.setAttribute('data-timestamp', +new Date());
                        script.addEventListener('load', function () {
                            
                            DISQUS.reset({reload: true, config: false});
                        });
                        (document.head || document.body).appendChild(script);
                    }
                });
            }, {
                root: null,
                rootMargin: "0px",
                threshold: [0]
            });
            disqusObserver.observe(document.querySelector(".comments"));
        }, false);</script></div></main><footer><p>&copy; Mirko Sertic &middot; <a href="https://www.mirkosertic.de/global/impressum/index.html">Imprint / Impressum</a></p><address><strong itemprop="name">Mirko Sertic</strong><div itemprop="address" itemscope itemtype="http://schema.org/PostalAddress"><div itemprop="streetAddress">Josefine-Mauser-Str. 66</div><div itemprop="postalCode">48157 Münster</div><div itemprop="addressCountry">Germany</div></div><a class="icon" target="_top" href="mailto:mirko@mirkosertic.de"><i class="fa fa-envelope-white"></i></a> <a class="icon" target="_blank" href="https://www.mirkosertic.de/index.xml" itemprop="url"><i class="fa fa-rss-white"></i></a> <a class="icon" target="_blank" href="https://www.xing.com/profile/Mirko_Sertic" itemprop="url"><i class="fa fa-xing-white"></i></a> <a class="icon" target="_blank" href="https://twitter.com/mirkosertic" itemprop="url"><i class="fa fa-twitter-white"></i></a> <a class="icon" target="_blank" href="https://github.com/mirkosertic" itemprop="url"><i class="fa fa-github-white"></i></a> <a class="icon" target="_blank" href="https://de.linkedin.com/in/mirko-sertic-98882397" itemprop="url"><i class="fa fa-linkedin-white"></i></a></address><p class="float-right"><a href="#">Back to top</a></p></footer><script src="https://www.mirkosertic.de/js/bootstrap-native-v4.min.js"></script><script>function existsByCSSSelector(aSelector) {
        var element = document.querySelector(aSelector);
        if (element) {
            return true;
        }
        return false;
    }

    var Loader = function () { };
    Loader.prototype = {
        require: function (scripts, callback) {
            this.loadCount = 0;
            this.totalRequired = scripts.length;
            this.callback = callback;

            for (var i=0;i<scripts.length;i++) {
                this.writeScript(scripts[i]);
            }
        },
        loaded: function (evt) {
            this.loadCount++;

            if (this.loadCount==this.totalRequired && typeof this.callback=='function') this.callback.call();
        },
        writeScript: function (src) {
            var self = this;
            var s = document.createElement('script');
            s.type = "text/javascript";
            s.async = true;
            s.src = src;
            s.addEventListener('load', function (e) { self.loaded(e); }, false);
            var head = document.getElementsByTagName('head')[0];
            head.appendChild(s);
        }
    };

    if (existsByCSSSelector("pre.highlight code") > 0) {
        var loader = new Loader();
        loader.require(["https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"], function() {

            var additionalStylesheet = document.createElement('link');
            additionalStylesheet.rel = "stylesheet";
            additionalStylesheet.type = 'text/css';
            additionalStylesheet.media = "screen";
            additionalStylesheet.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css";

            var head = document.getElementsByTagName('head')[0];
            head.appendChild(additionalStylesheet);

            hljs.highlightAll();
        });
    }</script></body></html>