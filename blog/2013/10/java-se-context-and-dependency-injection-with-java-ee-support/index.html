<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Enabling Java EE Features in CDI SE: A Portable Extension Magic Trick &middot; Mirko Sertic</title><meta name="description" content="Transform Java EE annotations into CDI-compatible magic using the power of Portable Extensions! Discover how to make @Resource and @RolesAllowed work seamlessly in Java SE environments through clever annotation transformation, without modifying your existing code."><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="robots" content="index,follow"><meta property="og:title" content="Enabling Java EE Features in CDI SE: A Portable Extension Magic Trick"><meta property="og:description" content="Transform Java EE annotations into CDI-compatible magic using the power of Portable Extensions! Discover how to make @Resource and @RolesAllowed work seamlessly in Java SE environments through clever annotation transformation, without modifying your existing code."><meta property="og:type" content="article"><meta property="og:url" content="https://www.mirkosertic.de/blog/2013/10/java-se-context-and-dependency-injection-with-java-ee-support/"><meta name="viewport" content="width=device-width,initial-scale=1"><link href="https://www.mirkosertic.de/css/site.css" rel="stylesheet" media="screen"><link rel="shortcut icon" type="image/x-icon" href="https://www.mirkosertic.de/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="https://www.mirkosertic.de/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://www.mirkosertic.de/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://www.mirkosertic.de/favicon-16x16.png"><link rel="manifest" href="https://www.mirkosertic.de/manifest.json"><link rel="mask-icon" href="https://www.mirkosertic.de/safari-pinned-tab.svg" color="#5bbad5"><meta name="theme-color" content="#ffffff"></head><body itemscope itemtype="http://schema.org/WebPage"><header><nav class="navbar navbar-expand-md navbar-dark fixed-top" itemscope itemtype="http://www.schema.org/SiteNavigationElement"><div class="container"><a class="navbar-brand" href="https://www.mirkosertic.de/">www.mirkosertic.de</a> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarCollapse"><ul class="navbar-nav mr-auto"><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/toolsgoodies" title="Tools &amp; Goodies">Tools &amp; Goodies</a></li><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/interestingbooks" title="Interesting Books">Interesting Books</a></li><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/favorites" title="My favorite postings">My favorite postings</a></li><li class="nav-item"><a itemprop="url" class="nav-link active" href="/post/" title="Blog">Blog</a></li></ul></div></div></nav></header><main role="main"><div itemprop="mainEntity" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header"><div class="contentbox"><h1 class="post-title" itemprop="name headline">Enabling Java EE Features in CDI SE: A Portable Extension Magic Trick</h1><p class="post-date"><span class="icon"><i class="fa fa-calendar-check-o-white"></i></span><time datetime="2013-10-03" itemprop="datePublished">Thu, Oct 3, 2013</time> <span>by</span> <span itemprop="author" itemscope="" itemtype="https://schema.org/Person"><span itemprop="name"><a href="https://x.com/mirkosertic" itemprop="url" rel="author">Mirko Sertic</a></span></span></p><p class="post-abstract" itemprop="abstract"><span>This article demonstrates how to enable Java EE features like security annotations and resource injection in a Java SE environment using CDI Portable Extensions. It explains the technique of transforming Java EE annotations (@Resource, @RolesAllowed) into CDI-compatible alternatives through container meta data manipulation, allowing developers to maintain their existing Java EE code while running in SE environments. The solution involves creating a custom extension that rewrites annotations and implements security checks using interceptors, all without requiring modification of the original code or additional third-party dependencies.</span></p><p><span class="icon"><i class="fa fa-clock-white"></i></span><span>5 Minutes reading time</span></p><p class="post-tags"><span class="tag"><span class="icon"><i class="fa fa-tags-white"></i></span><a href="/tags/modernization">Modernization</a></span></p></div></header><article class="post-content clearfix" itemprop="articleBody"><div class="paragraph"><p>Java CDI(Context and Dependency Injection) JSR-299 is available on Java EE application servers, but CDI(Weld is the reference implementation) is also embeddable in Java SE standard edition. Unfortunately Java EE functionalities like security or transaction support are not available here, for instance the following code just does not work as expected when running on CDI SE:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">@Singleton
public class WeldBean {

    @Resource
    Principal principal;

    @RolesAllowed(&#34;securedrole&#34;)
    public void run() {
        System.out.println(&#34;Hello World : &#34;+principal);
    }
}</code></pre></div></div><div class="paragraph"><p>The @Resource and @RolesAllowed annotations are not evaluated on Weld SE by default. Now, how can we enable these Java EE features?</p></div><div class="paragraph"><p>The @Resource annotation is a problem, but the biggest problem is the @RolesAllowed annotation. This security check can by done by using an CDI interceptor, but the @RolesAllowed annotation does not support @InterceptorBinding. How can be enable security check without introducing new annotations in our code?</p></div><div class="paragraph"><p>The answer is quite simple. We use the CDI Portable Extension API. This API allows us to manipulate the CDI container meta data before it is processed by the CDI runtime. But how does this help?</p></div><div class="paragraph"><p>Well, with a CDI extension we can rewrite the given annotations from out code, and change it, for instance replace the @Resource annotation with @Inject, and this can be processed by the CDI SE runtime and will inject managed beans created from classes or producer methods for instance.</p></div><div class="paragraph"><p>The tricky part is the @RolesAllowed annotation. A custom annotation is added to such annotated methods, with @InterceptorBinding. Now, a security interceptor checks for permissions and will continue with execution. In our case, the @MySecurityAnnotation is added to the method, and the following interceptor will check the permissions:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">@Interceptor
@MySecurityAnnotation
public class MySecurityInterceptor {

    @AroundInvoke
    public Object aroundCheck(InvocationContext aContext) throws Exception {
        RolesAllowed theRolesAllowed = aContext.getMethod().getAnnotation(RolesAllowed.class);
        System.out.println(&#34;Secured Method check : Allowed roles : &#34; + theRolesAllowed.value()[0]);
        return aContext.proceed();
    }
}</code></pre></div></div><div class="paragraph"><p>The tricky thing is we have to extract the original @RolesAllowed annotation from the method signature. It is still there as we use the Java reflection API to extract it. We just modified the CDI container meta data, not the Bytecode.</p></div><div class="paragraph"><p>Simple but efficient. Using the same pattern, we can also implement transaction support with CDI running on Java SE. But how does the CDI extension work? The following code should show how this can be done. It can also be simplified using Weld Extensions API or Seam Solder, but here is everything without third party dependencies:</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">public class MyExtension implements Extension {

    static class ResourceInjectAlias implements Annotation, Inject {
        public Class&lt;? extends Annotation&gt; annotationType() {
            return Inject.class;
        }
    }

    static final ResourceInjectAlias INJECT_ALIAS = new ResourceInjectAlias();

    static class SecurityAlias implements Annotation, MySecurityAnnotation {

        public Class&lt;? extends Annotation&gt; annotationType() {
            return MySecurityAnnotation.class;
        }
    }

    static final SecurityAlias SECURITY_ALIAS = new SecurityAlias();

    &lt;X&gt; void processBean(@Observes ProcessAnnotatedType&lt;X&gt; aEvent, BeanManager aBeanManager) {

        final AnnotatedType&lt;X&gt; theType = aEvent.getAnnotatedType();

        AnnotatedType&lt;X&gt; theWrapped = new AnnotatedType&lt;X&gt;() {
            public Class&lt;X&gt; getJavaClass() {
                return theType.getJavaClass();
            }

            public Set&lt;AnnotatedConstructor&lt;X&gt;&gt; getConstructors() {
                return theType.getConstructors();
            }

            public Set&lt;AnnotatedMethod&lt;? super X&gt;&gt; getMethods() {
                Set&lt;AnnotatedMethod&lt;? super X&gt;&gt; theResult = new HashSet&lt;AnnotatedMethod&lt;? super X&gt;&gt;();
                for (AnnotatedMethod theMethod : theType.getMethods()) {
                    if (theMethod.isAnnotationPresent(RolesAllowed.class)) {
                        final AnnotatedMethod theOriginal = theMethod;

                        theResult.add(new AnnotatedMethod&lt;X&gt;() {
                            public Method getJavaMember() {
                                return theOriginal.getJavaMember();
                            }

                            public List&lt;AnnotatedParameter&lt;X&gt;&gt; getParameters() {
                                return theOriginal.getParameters();
                            }

                            public boolean isStatic() {
                                return theOriginal.isStatic();
                            }

                            public AnnotatedType&lt;X&gt; getDeclaringType() {
                                return theOriginal.getDeclaringType();
                            }

                            public Type getBaseType() {
                                return theOriginal.getBaseType();
                            }

                            public Set&lt;Type&gt; getTypeClosure() {
                                return theOriginal.getTypeClosure();
                            }

                            public &lt;T extends Annotation&gt; T getAnnotation(Clas&lt;T&gt; annotationType) {
                                return theOriginal.getAnnotation(annotationType);
                            }

                            public Set&lt;Annotation&gt; getAnnotations() {
                                Set&lt;Annotation&gt; theResult = new HashSet&lt;Annotation&gt;();
                                theResult.addAll(theOriginal.getAnnotations());
                                theResult.add(SECURITY_ALIAS);
                                return theResult;
                            }

                            public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationType) {
                                return theOriginal.isAnnotationPresent(annotationType);
                            }
                        });
                    } else {
                        theResult.add(theMethod);
                    }
                }
                return theResult;
            }

            public Set&lt;AnnotatedField&lt;? super X&gt;&gt; getFields() {
                Set&lt;AnnotatedField&lt;? super X&gt;&gt; theResult = new HashSet&lt;AnnotatedField&lt;? super X&gt;&gt;();
                for (AnnotatedField theField : theType.getFields()) {
                    if (theField.isAnnotationPresent(Resource.class)) {

                        final AnnotatedField theOriginal = theField;

                        theResult.add(new AnnotatedField&lt;X&gt;() {
                            public Field getJavaMember() {
                                return theOriginal.getJavaMember();
                            }

                            public boolean isStatic() {
                                return theOriginal.isStatic();
                            }

                            public AnnotatedType&lt;X&gt; getDeclaringType() {
                                return theOriginal.getDeclaringType();
                            }

                            public Type getBaseType() {
                                return theOriginal.getBaseType();
                            }

                            public Set&lt;Type&gt; getTypeClosure() {
                                return theOriginal.getTypeClosure();
                            }

                            public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationType) {
                                return theOriginal.getAnnotation(annotationType);
                            }

                            public Set&lt;Annotation&gt; getAnnotations() {
                                Set&lt;Annotation&gt; theResult = new HashSet&lt;Annotation&gt;();
                                theResult.addAll(theOriginal.getAnnotations());
                                theResult.add(INJECT_ALIAS);
                                return theResult;
                            }

                            public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationType) {
                                return theOriginal.isAnnotationPresent(annotationType);
                            }
                        });
                    } else {
                        theResult.add(theField);
                    }
                }
                return theResult;
            }

            public Type getBaseType() {
                return theType.getBaseType();
            }

            public Set&lt;Type&gt; getTypeClosure() {
                return theType.getTypeClosure();
            }

            public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationType) {
                return theType.getAnnotation(annotationType);
            }

            public Set&lt;Annotation&gt; getAnnotations() {
                return theType.getAnnotations();
            }

            public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationType) {
                return theType.isAnnotationPresent(annotationType);
            }
        };
        aEvent.setAnnotatedType(theWrapped);
    }
}</code></pre></div></div><div class="paragraph"><p>This does all the job, replace @Resource with @Inject and add the @MySecurityAnnotation to @RolesAllowed annotated method so their execution is intercepted by the security interceptor. Here we just rewrite the field or method level annotations, but to get full CDI support, we would also have to rewrite constructor annotations. But i hope you get how this can be done by looking at the code. If you want to read more about Weld, CDI and the Portable Extension API, i suggest to read the <a href="http://docs.jboss.org/weld/extensions/reference/latest/en-US/html_single/">Weld Portable Extension Documentation</a>.</p></div><div class="paragraph"><p>Weld offers of course a SPI which can do the same thing. But the CDI Extension API is a container independent way to implement Java EE security and transaction support with Weld CDI running on Java SE standard edition. I really love it :-)</p></div><div class="metainfo"><span>&lt;&lt;Pevious posting: <a href="https://www.mirkosertic.de/blog/2013/10/how-to-create-junit-assertions-from-running-applications/">JUnit Test Assertions Made Easy: Generate Instead of Write</a></span> <span>Next posting: <a href="https://www.mirkosertic.de/blog/2013/10/java-array-iterator-performance/">The Hidden Cost of Array Iteration: A Java Performance Deep Dive</a>&gt;&gt;</span></div><p><i class="fa fa-github"></i>Git revision: <a href="https://github.com/mirkosertic/www_mirkosertic_de/commit/c80594730cca2933f4a385caf46fddef187449d3" target="_blank">c805947</a></p></article></div></main><footer><p>&copy; Mirko Sertic &middot; <a href="https://www.mirkosertic.de/global/impressum/index.html">Imprint / Impressum</a></p><address><strong itemprop="name">Mirko Sertic</strong><div itemprop="address" itemscope itemtype="http://schema.org/PostalAddress"><div itemprop="streetAddress">Josefine-Mauser-Str. 66</div><div itemprop="postalCode">48157 Münster</div><div itemprop="addressCountry">Germany</div></div><a class="icon" target="_top" href="mailto:mirko@mirkosertic.de"><i class="fa fa-envelope-white"></i></a> <a class="icon" target="_blank" href="https://x.com/mirkosertic" itemprop="url"><i class="fa fa-x-twitter-white"></i></a> <a class="icon" target="_blank" href="https://github.com/mirkosertic" itemprop="url"><i class="fa fa-github-white"></i></a> <a class="icon" target="_blank" href="https://de.linkedin.com/in/mirko-sertic-98882397" itemprop="url"><i class="fa fa-linkedin-white"></i></a></address><p class="float-right"><a href="#">Back to top</a></p></footer><script src="https://www.mirkosertic.de/js/bootstrap-native-v4.min.js"></script><script>function existsByCSSSelector(aSelector) {
        var element = document.querySelector(aSelector);
        if (element) {
            return true;
        }
        return false;
    }

    var Loader = function () { };
    Loader.prototype = {
        require: function (scripts, callback) {
            this.loadCount = 0;
            this.totalRequired = scripts.length;
            this.callback = callback;

            for (var i=0;i<scripts.length;i++) {
                this.writeScript(scripts[i]);
            }
        },
        loaded: function (evt) {
            this.loadCount++;

            if (this.loadCount==this.totalRequired && typeof this.callback=='function') this.callback.call();
        },
        writeScript: function (src) {
            var self = this;
            var s = document.createElement('script');
            s.type = "text/javascript";
            s.async = true;
            s.src = src;
            s.addEventListener('load', function (e) { self.loaded(e); }, false);
            var head = document.getElementsByTagName('head')[0];
            head.appendChild(s);
        }
    };

    if (existsByCSSSelector("pre.highlight code") > 0) {
        var loader = new Loader();
        loader.require(["https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"], function() {

            var additionalStylesheet = document.createElement('link');
            additionalStylesheet.rel = "stylesheet";
            additionalStylesheet.type = 'text/css';
            additionalStylesheet.media = "screen";
            additionalStylesheet.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css";

            var head = document.getElementsByTagName('head')[0];
            head.appendChild(additionalStylesheet);

            hljs.highlightAll();
        });
    }</script></body></html>