<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Transform Wonky Magnetometer Data into Perfect Circles: A Python Guide &middot; Mirko Sertic</title><meta name="description" content="Discover how to turn messy magnetometer readings into perfect circles using Python&#39;s ellipsoid fitting magic! This mathematical journey transforms scattered data points into calibrated compass readings by battling hard iron effects and sensor noise - all visualized in beautiful plots."><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="robots" content="index,follow"><meta property="og:title" content="Transform Wonky Magnetometer Data into Perfect Circles: A Python Guide"><meta property="og:description" content="Discover how to turn messy magnetometer readings into perfect circles using Python&#39;s ellipsoid fitting magic! This mathematical journey transforms scattered data points into calibrated compass readings by battling hard iron effects and sensor noise - all visualized in beautiful plots."><meta property="og:type" content="article"><meta property="og:url" content="https://www.mirkosertic.de/blog/2023/01/magnetometer-calibration-ellipsoid/"><meta name="viewport" content="width=device-width,initial-scale=1"><link href="https://www.mirkosertic.de/css/site.css" rel="stylesheet" media="screen"><link rel="shortcut icon" type="image/x-icon" href="https://www.mirkosertic.de/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="https://www.mirkosertic.de/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://www.mirkosertic.de/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://www.mirkosertic.de/favicon-16x16.png"><link rel="manifest" href="https://www.mirkosertic.de/manifest.json"><link rel="mask-icon" href="https://www.mirkosertic.de/safari-pinned-tab.svg" color="#5bbad5"><meta name="theme-color" content="#ffffff"><script>var _paq = window._paq = window._paq || [];

        _paq.push(['trackPageView']);
        _paq.push(['enableLinkTracking']);
        _paq.push(['requireConsent']);

        (function() {
            
            function isDoNotTrackEnabled() {
                return navigator.doNotTrack === "1" ||
                    window.doNotTrack === "1" ||
                    navigator.msDoNotTrack === "1";
            }

            
            function createConsentBanner() {
                
                if (isDoNotTrackEnabled()) {
                    initializeMatomo(false);
                    return;
                }

                var banner = document.createElement('div');
                banner.style.cssText = `
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #f8f8f8;
            padding: 15px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            text-align: center;
        `;

                banner.innerHTML = `
            <p>We use cookies to improve your browsing experience.
            Your browser's Do Not Track setting is currently: ${isDoNotTrackEnabled() ? 'Enabled' : 'Disabled'}.
            Do you consent to our use of cookies?</p>
            <button id="accept-cookies" style="background-color: #4CAF50; color: white; border: none; padding: 10px 20px; margin-right: 10px; cursor: pointer;">
                Accept
            </button>
            <button id="reject-cookies" style="background-color: #f44336; color: white; border: none; padding: 10px 20px; cursor: pointer;">
                Reject
            </button>
        `;

                document.body.appendChild(banner);

                
                document.getElementById('accept-cookies').addEventListener('click', function() {
                    banner.style.display = 'none';
                    localStorage.setItem('matomoConsent', 'accepted');
                    initializeMatomo(true);
                });

                
                document.getElementById('reject-cookies').addEventListener('click', function() {
                    banner.style.display = 'none';
                    localStorage.setItem('matomoConsent', 'rejected');
                    initializeMatomo(false);
                });
            }

            
            function initializeMatomo(trackingAllowed) {
                
                if (isDoNotTrackEnabled()) {
                    trackingAllowed = false;
                }

                if (trackingAllowed) {
                    
                    _paq.push(['setConsentGiven']);
                }
            }

            
            function checkPreviousConsent() {
                
                if (isDoNotTrackEnabled()) {
                    initializeMatomo(false);
                    return;
                }

                var storedConsent = localStorage.getItem('matomoConsent');
                if (storedConsent === 'accepted') {
                    console.log("Tracking accepted");
                    initializeMatomo(true);
                } else if (storedConsent === 'rejected') {
                    console.log("Tracking rejected");
                    initializeMatomo(false);
                } else {
                    
                    createConsentBanner();
                }
            }

            
            function init() {
                checkPreviousConsent();
            }

            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }

            var u="//analytics.mirkosertic.de/";
            _paq.push(['setTrackerUrl', u+'matomo.php']);
            _paq.push(['setSiteId', '2']);

            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
            g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
        })();</script></head><body itemscope itemtype="http://schema.org/WebPage"><header><nav class="navbar navbar-expand-md navbar-dark fixed-top" itemscope itemtype="http://www.schema.org/SiteNavigationElement"><div class="container"><a class="navbar-brand" href="https://www.mirkosertic.de/">www.mirkosertic.de</a> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarCollapse"><ul class="navbar-nav mr-auto"><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/toolsgoodies" title="My personal Technology Radar">Technology Radar</a></li><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/interestingbooks" title="Interesting Books">Essential Books</a></li><li class="nav-item"><a itemprop="url" class="nav-link" href="/global/favorites" title="My favorite postings">My favorite postings</a></li><li class="nav-item"><a itemprop="url" class="nav-link active" href="/post/" title="Blog">Blog</a></li></ul></div></div></nav></header><main role="main"><div itemprop="mainEntity" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header"><div class="contentbox"><h1 class="post-title" itemprop="name headline">Transform Wonky Magnetometer Data into Perfect Circles: A Python Guide</h1><p class="post-date"><span class="icon"><i class="fa fa-calendar-check-o-white"></i></span><time datetime="2023-01-12" itemprop="datePublished">Thu, Jan 12, 2023</time> <span>by</span> <span itemprop="author" itemscope="" itemtype="https://schema.org/Person"><span itemprop="name"><a href="https://x.com/mirkosertic" rel="author">Mirko Sertic</a></span></span></p><p class="post-abstract" itemprop="abstract"><span>A comprehensive guide demonstrating the calibration process for 2D magnetometer data using ellipsoid fitting techniques in Python. The tutorial walks through loading raw magnetometer data, visualizing the distorted measurements, calculating the best-fitting ellipsoid, and applying corrections to achieve properly calibrated circular output. The solution handles sensor noise and hard iron effects while providing clear visual feedback through matplotlib plots, making it particularly useful for robotics applications requiring accurate compass readings.</span></p><p><span class="icon"><i class="fa fa-clock-white"></i></span><span>6 Minutes reading time</span></p><p class="post-tags"><span class="tag"><span class="icon"><i class="fa fa-tags-white"></i></span><a href="/tags/roomba">Roomba</a> ,<a href="/tags/robot">Robot</a> ,<a href="/tags/magnetometer">Magnetometer</a></span></p></div></header><figure class="blogtitleimage"><figcaption><p>Behold the masterpiece that AI hallucinated while reading this post:</p><p class="title">"The Little Magnet That Couldn&#39;t Point North (Until Python Helped)"</p><p>(after I fed it way too many marketing blogs and memes)</p><p class="aidisclosure">Created using DALL-E 3</p></figcaption><img src="/media/welcomeimages/magnetometer-calibration-ellipsoid_selected.png" alt="AI-Generated: The Little Magnet That Couldn&#39;t Point North (Until Python Helped)" itemprop="image"></figure><article class="post-content clearfix" itemprop="articleBody"><div class="sect1"><h2 id="_how_to_calibrate_a_2d_magnetometer_with_ellipsoid_fitting">How to calibrate a 2D magnetometer with ellipsoid fitting</h2><div class="sectionbody"><div class="sect2"><h3 id="_step_1_load_uncalibrated_magnetometer_data_as_csv">Step 1: Load uncalibrated magnetometer data as CSV</h3><div class="paragraph"><p>The data was recorded by logging data from the magnetometer.</p></div><div class="paragraph"><p>Take care! This calibration process should be done while all systems of your robot or solution are running, so in a real life environment. This will make sure we take all hard iron influences into consideration. Place the robot in the middle of a room and let your robot turn to the left and to the right for a minute, and record the data.</p></div><div class="paragraph"><p><strong>In[1]:</strong></p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python">import math
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse

rawdata = pd.read_csv(&#39;mag_out.csv&#39;)</code></pre></div></div></div><div class="sect2"><h3 id="_step_2_visualize_the_data_to_see_what_is_going_on">Step 2: Visualize the data to see what is going on</h3><div class="paragraph"><p>The easiest way is to plot the data on the x/y plane as a scatter plot. Every point represents a measurement of the magnetic field. We should see a perfect circle here, centered at (0,0).</p></div><div class="paragraph"><p>Due due hard iron effects, we do not see a circle, but an ellipse. There are also outliers related to sensor noise. It also seems not to be centered at (0,0) at all.</p></div><div class="paragraph"><p>Goal of the calibration procedure is to find a way to transform the measurements back into a circle.</p></div><div class="paragraph"><p><strong>In[2]:</strong></p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python">plt.scatter(rawdata[&#34;x&#34;], rawdata[&#34;y&#34;], label=&#39;Data Points&#39;, color=&#39;b&#39;)
plt.show()</code></pre></div></div><div class="paragraph"><p><strong>Out[2]:</strong></p></div><div class="paragraph"><p><span class="image"><img src="/media/ellipsoid_output_4_0.png" alt="ellipsoid output 4 0"></span></p></div></div><div class="sect2"><h3 id="_step_3_calculate_the_ellipsoid">Step 3: Calculate the ellipsoid</h3><div class="paragraph"><p>Ellipsoid fitting tries to find the best fitting ellipsoid in the data. During this process, outliers are mostly eliminated and sensor noise reduced. As the result, we get the center point of the ellipsoid, the length of its axes and also its orientation.</p></div><div class="paragraph"><p><strong>In[3]:</strong></p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python">xcol = rawdata[&#34;x&#34;]
ycol = rawdata[&#34;y&#34;]

xmin = xcol.min()
xmax = xcol.max()

ymin = ycol.min()
ymax = ycol.max()

width = xmax - xmin
height = ymax - ymin
xyratio = width / height

# Code taken from https://scipython.com/blog/direct-linear-least-squares-fitting-of-an-ellipse/
def fit_ellipse(x, y):
    &#34;&#34;&#34;

    Fit the coefficients a,b,c,d,e,f, representing an ellipse described by
    the formula F(x,y) = ax^2 + bxy + cy^2 + dx + ey + f = 0 to the provided
    arrays of data points x=[x1, x2, ..., xn] and y=[y1, y2, ..., yn].

    Based on the algorithm of Halir and Flusser, &#34;Numerically stable direct
    least squares fitting of ellipses&#39;.


    &#34;&#34;&#34;

    D1 = np.vstack([x**2, x*y, y**2]).T
    D2 = np.vstack([x, y, np.ones(len(x))]).T
    S1 = D1.T @ D1
    S2 = D1.T @ D2
    S3 = D2.T @ D2
    T = -np.linalg.inv(S3) @ S2.T
    M = S1 + S2 @ T
    C = np.array(((0, 0, 2), (0, -1, 0), (2, 0, 0)), dtype=float)
    M = np.linalg.inv(C) @ M
    eigval, eigvec = np.linalg.eig(M)
    con = 4 * eigvec[0]* eigvec[2] - eigvec[1]**2
    ak = eigvec[:, np.nonzero(con &gt; 0)[0]]
    return np.concatenate((ak, T @ ak)).ravel()

def cart_to_pol(coeffs):
    &#34;&#34;&#34;

    Convert the cartesian conic coefficients, (a, b, c, d, e, f), to the
    ellipse parameters, where F(x, y) = ax^2 + bxy + cy^2 + dx + ey + f = 0.
    The returned parameters are x0, y0, ap, bp, e, phi, where (x0, y0) is the
    ellipse centre; (ap, bp) are the semi-major and semi-minor axes,
    respectively; e is the eccentricity; and phi is the rotation of the semi-
    major axis from the x-axis.

    &#34;&#34;&#34;

    # We use the formulas from https://mathworld.wolfram.com/Ellipse.html
    # which assumes a cartesian form ax^2 + 2bxy + cy^2 + 2dx + 2fy + g = 0.
    # Therefore, rename and scale b, d and f appropriately.
    a = coeffs[0]
    b = coeffs[1] / 2
    c = coeffs[2]
    d = coeffs[3] / 2
    f = coeffs[4] / 2
    g = coeffs[5]

    den = b**2 - a*c
    if den &gt; 0:
        raise ValueError(&#39;coeffs do not represent an ellipse: b^2 - 4ac must&#39;
                         &#39; be negative!&#39;)

    # The location of the ellipse centre.
    x0, y0 = (c*d - b*f) / den, (a*f - b*d) / den

    num = 2 * (a*f**2 + c*d**2 + g*b**2 - 2*b*d*f - a*c*g)
    fac = np.sqrt((a - c)**2 + 4*b**2)
    # The semi-major and semi-minor axis lengths (these are not sorted).
    ap = np.sqrt(num / den / (fac - a - c))
    bp = np.sqrt(num / den / (-fac - a - c))

    # Sort the semi-major and semi-minor axis lengths but keep track of
    # the original relative magnitudes of width and height.
    width_gt_height = True
    if ap &lt; bp:
        width_gt_height = False
        ap, bp = bp, ap

    # The eccentricity.
    r = (bp/ap)**2
    if r &gt; 1:
        r = 1/r
    e = np.sqrt(1 - r)

    # The angle of anticlockwise rotation of the major-axis from x-axis.
    if b == 0:
        phi = 0 if a &lt; c else np.pi/2
    else:
        phi = np.arctan((2.*b) / (a - c)) / 2
        if a &gt; c:
            phi += np.pi/2
    if not width_gt_height:
        # Ensure that phi is the angle to rotate to the semi-major axis.
        phi += np.pi/2
    phi = phi % np.pi

    return x0, y0, ap, bp, e, phi

coeffs = fit_ellipse(xcol, ycol)
x0, y0, ap, bp, e, phi = cart_to_pol(coeffs)

rat = ap / bp

[rat, width, height, x0, y0, ap, bp, e, math.degrees(phi)]</code></pre></div></div><div class="paragraph"><p><strong>Out[3]:</strong></p></div><div class="listingblock"><div class="content"><pre>[1.0796413094280661,
400.20000000000005,
353.28000000000003,
-1233.400221573585,
-470.075066520626,
163.20561364076153,
151.16651448546256,
0.3769501500025899,
4.9892937074437285]</pre></div></div><div class="paragraph"><p><strong>In[4]:</strong></p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python">ellipse = Ellipse((x0, y0), ap * 2, bp * 2, color=&#39;r&#39;, angle=math.degrees(phi), fill=False)

fig, ax = plt.subplots()
ax.add_patch(ellipse)
ax.scatter(xcol, ycol, label=&#39;Data Points&#39;, color=&#39;b&#39;)

plt.plot([x0 - math.cos(phi) * bp, x0 + math.cos(phi) * bp], [y0  - math.sin(phi) * ap, y0 + math.sin(phi) * ap], color=&#39;r&#39;, linestyle=&#39;-&#39;, linewidth=1)
plt.plot([x0 - math.cos(phi + math.pi / 2) * bp, x0 + math.cos(phi + math.pi / 2) * bp], [y0 - math.sin(phi + math.pi / 2) * ap, y0 + math.sin(phi + math.pi / 2) * ap], color=&#39;r&#39;, linestyle=&#39;-&#39;, linewidth=1)

plt.show()</code></pre></div></div><div class="paragraph"><p><strong>Out[4]:</strong></p></div><div class="paragraph"><p><span class="image"><img src="/media/ellipsoid_output_7_0.png" alt="ellipsoid output 7 0"></span></p></div></div><div class="sect2"><h3 id="_step_4_apply_offsets_and_rotation_to_data">Step 4: Apply offsets and rotation to data</h3><div class="paragraph"><p>We apply the found hard iron offsets, scale factors and rotation compensations to the data points to make it the best circle we can.</p></div><div class="paragraph"><p><strong>In[5]:</strong></p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python">rot = round(phi / (math.pi / 2.0))
rotation = -(phi - rot * math.pi / 2.0)

def correctdata(row):
    x = row[&#34;x&#34;] - x0
    y = row[&#34;y&#34;] - y0
    return [x * np.cos(rotation) - y * np.sin(rotation),
            (x * np.sin(rotation) + y * np.cos(rotation)) * rat]

res = rawdata.apply(correctdata, axis=1, result_type=&#39;expand&#39;)
rawdata[&#34;xcorrected&#34;] = res[0]
rawdata[&#34;ycorrected&#34;] = res[1]

math.degrees(phi), math.degrees(rotation)</code></pre></div></div><div class="paragraph"><p><strong>Out[5]:</strong></p></div><div class="listingblock"><div class="content"><pre>(4.9892937074437285, -4.9892937074437285)</pre></div></div></div><div class="sect2"><h3 id="_finally_the_corrected_data">Finally, the corrected data</h3><div class="paragraph"><p>Here we are, this is the result when the calibration is applied. The center of the circle is at (0,0). There is also a green circle in the background showing the layout of a perfect circle to see the difference.</p></div><div class="paragraph"><p><strong>In[6]:</strong></p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python">circle = plt.Circle((0, 0), ap, color=&#39;g&#39;, alpha=0.2)

fig, ax = plt.subplots()
ax.add_patch(circle)
ax.scatter(rawdata[&#34;xcorrected&#34;], rawdata[&#34;ycorrected&#34;], label=&#39;Data Points&#39;, color=&#39;b&#39;)

plt.show()</code></pre></div></div><div class="paragraph"><p><strong>Out[6]:</strong></p></div><div class="paragraph"><p><span class="image"><img src="/media/ellipsoid_output_11_0.png" alt="ellipsoid output 11 0"></span></p></div></div></div></div><h1 id="summary" class="sect0">Summary</h1><div class="sect1"><h2 id="pros">Pros</h2><div class="sectionbody"><div class="ulist"><ul><li><p>Sensor noise and outliers are well handled</p></li><li><p>Directional and rotational offsets are corrected</p></li><li><p>Works with a small set of data points to start calibration</p></li></ul></div></div></div><div class="sect1"><h2 id="cons">Cons</h2><div class="sectionbody"><div class="ulist"><ul><li><p>Computationally intensive</p></li><li><p>Harder math</p></li><li><p>Harder to debug</p></li></ul></div></div></div><div class="metainfo"><span>&lt;&lt;Pevious posting: <a href="https://www.mirkosertic.de/blog/2022/10/roomba-series-1/">Building a Smart Roomba: A Symphony of Hardware and ROS</a></span> <span>Next posting: <a href="https://www.mirkosertic.de/blog/2024/11/enhance-blog-with-ai/">Supercharge Your Hugo Blog with Claude: Automated Content Enhancement using Anthropic&#39;s API</a>&gt;&gt;</span></div><p><i class="fa fa-github"></i>Git revision: <a href="https://github.com/mirkosertic/www_mirkosertic_de/commit/2e692ad1fff282e93d9fa3fdd726190d7e7afd82" target="_blank">2e692ad</a></p></article></div></main><footer><p>&copy; Mirko Sertic &middot; <a href="https://www.mirkosertic.de/global/impressum/index.html">Imprint / Impressum</a></p><address><strong itemprop="name">Mirko Sertic</strong><div itemprop="address" itemscope itemtype="http://schema.org/PostalAddress"><div itemprop="streetAddress">Josefine-Mauser-Straße 66</div><div itemprop="postalCode">48157 Münster</div><div itemprop="addressCountry">Germany</div></div><a class="icon" target="_top" href="mailto:mirko@mirkosertic.de"><i class="fa fa-envelope-white"></i></a> <a class="icon" target="_blank" href="https://www.xing.com/profile/Mirko_Sertic" itemprop="url"><i class="fa fa-xing-white"></i></a> <a class="icon" target="_blank" href="https://bsky.app/profile/mirkosertic.de" itemprop="url"><i class="fa fa-bluesky-white"></i></a> <a class="icon" target="_blank" href="https://x.com/mirkosertic" itemprop="url"><i class="fa fa-x-twitter-white"></i></a> <a class="icon" target="_blank" href="https://github.com/mirkosertic" itemprop="url"><i class="fa fa-github-white"></i></a> <a class="icon" target="_blank" href="https://de.linkedin.com/in/mirko-sertic-98882397" itemprop="url"><i class="fa fa-linkedin-white"></i></a></address><p class="float-right"><a href="#">Back to top</a></p></footer><script src="https://www.mirkosertic.de/js/bootstrap-native-v4.min.js"></script><script>function existsByCSSSelector(aSelector) {
        var element = document.querySelector(aSelector);
        if (element) {
            return true;
        }
        return false;
    }

    var Loader = function () { };
    Loader.prototype = {
        require: function (scripts, callback) {
            this.loadCount = 0;
            this.totalRequired = scripts.length;
            this.callback = callback;

            for (var i=0;i<scripts.length;i++) {
                this.writeScript(scripts[i]);
            }
        },
        loaded: function (evt) {
            this.loadCount++;

            if (this.loadCount==this.totalRequired && typeof this.callback=='function') this.callback.call();
        },
        writeScript: function (src) {
            var self = this;
            var s = document.createElement('script');
            s.type = "text/javascript";
            s.async = true;
            s.src = src;
            s.addEventListener('load', function (e) { self.loaded(e); }, false);
            var head = document.getElementsByTagName('head')[0];
            head.appendChild(s);
        }
    };

    if (existsByCSSSelector("pre.highlight code") > 0) {
        var loader = new Loader();
        loader.require(["https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"], function() {

            var additionalStylesheet = document.createElement('link');
            additionalStylesheet.rel = "stylesheet";
            additionalStylesheet.type = 'text/css';
            additionalStylesheet.media = "screen";
            additionalStylesheet.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css";

            var head = document.getElementsByTagName('head')[0];
            head.appendChild(additionalStylesheet);

            hljs.highlightAll();
        });
    }</script></body></html>