{"version":3,"sources":["../../src/extras/BitmapText.js"],"names":["core","BitmapText","text","style","textWidth","textHeight","_glyphs","_font","tint","undefined","align","name","size","font","_text","maxWidth","maxLineHeight","_anchor","dirty","updateText","data","fonts","scale","pos","Point","chars","lineWidths","prevCharCode","lastLineWidth","maxLineWidth","line","lastSpace","lastSpaceWidth","i","length","charCode","charCodeAt","test","charAt","push","Math","max","x","y","lineHeight","utils","removeItems","charData","kerning","texture","position","xOffset","yOffset","width","xAdvance","height","lineAlignOffsets","alignOffset","lenChars","c","Sprite","parent","addChild","removeChild","anchor","updateTransform","validate","containerUpdateTransform","getLocalBounds","value","set","copy","split","slice","join","parseInt","toString","Container"],"mappings":";;;;;;AAAA;;IAAYA,I;;AACZ;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;IAkBqBC,U;;;AAEjB;;;;;;;;;;;AAWA,wBAAYC,IAAZ,EACA;AAAA,YADkBC,KAClB,uEAD0B,EAC1B;;AAAA;;AAGI;;;;;;;AAHJ,qDACI,0BADJ;;AAUI,cAAKC,SAAL,GAAiB,CAAjB;;AAEA;;;;;;;AAOA,cAAKC,UAAL,GAAkB,CAAlB;;AAEA;;;;;;AAMA,cAAKC,OAAL,GAAe,EAAf;;AAEA;;;;;;AAMA,cAAKC,KAAL,GAAa;AACTC,kBAAML,MAAMK,IAAN,KAAeC,SAAf,GAA2BN,MAAMK,IAAjC,GAAwC,QADrC;AAETE,mBAAOP,MAAMO,KAAN,IAAe,MAFb;AAGTC,kBAAM,IAHG;AAITC,kBAAM;AAJG,SAAb;;AAOA;;;;;;AAMA,cAAKC,IAAL,GAAYV,MAAMU,IAAlB,CAhDJ,CAgD4B;;AAExB;;;;;;AAMA,cAAKC,KAAL,GAAaZ,IAAb;;AAEA;;;;;;;AAOA,cAAKa,QAAL,GAAgB,CAAhB;;AAEA;;;;;;AAMA,cAAKC,aAAL,GAAqB,CAArB;;AAEA;;;;;;AAMA,cAAKC,OAAL,GAAe,8BAAoB,YAAM;AAAE,kBAAKC,KAAL,GAAa,IAAb;AAAoB,SAAhD,SAAwD,CAAxD,EAA2D,CAA3D,CAAf;;AAEA;;;;;AAKA,cAAKA,KAAL,GAAa,KAAb;;AAEA,cAAKC,UAAL;AA1FJ;AA2FC;;AAED;;;;;;;yBAKAA,U,yBACA;AACI,YAAMC,OAAOnB,WAAWoB,KAAX,CAAiB,KAAKd,KAAL,CAAWI,IAA5B,CAAb;AACA,YAAMW,QAAQ,KAAKf,KAAL,CAAWK,IAAX,GAAkBQ,KAAKR,IAArC;AACA,YAAMW,MAAM,IAAIvB,KAAKwB,KAAT,EAAZ;AACA,YAAMC,QAAQ,EAAd;AACA,YAAMC,aAAa,EAAnB;;AAEA,YAAIC,eAAe,IAAnB;AACA,YAAIC,gBAAgB,CAApB;AACA,YAAIC,eAAe,CAAnB;AACA,YAAIC,OAAO,CAAX;AACA,YAAIC,YAAY,CAAC,CAAjB;AACA,YAAIC,iBAAiB,CAArB;AACA,YAAIhB,gBAAgB,CAApB;;AAEA,aAAK,IAAIiB,IAAI,CAAb,EAAgBA,IAAI,KAAK/B,IAAL,CAAUgC,MAA9B,EAAsCD,GAAtC,EACA;AACI,gBAAME,WAAW,KAAKjC,IAAL,CAAUkC,UAAV,CAAqBH,CAArB,CAAjB;;AAEA,gBAAI,OAAOI,IAAP,CAAY,KAAKnC,IAAL,CAAUoC,MAAV,CAAiBL,CAAjB,CAAZ,CAAJ,EACA;AACIF,4BAAYE,CAAZ;AACAD,iCAAiBJ,aAAjB;AACH;;AAED,gBAAI,iBAAiBS,IAAjB,CAAsB,KAAKnC,IAAL,CAAUoC,MAAV,CAAiBL,CAAjB,CAAtB,CAAJ,EACA;AACIP,2BAAWa,IAAX,CAAgBX,aAAhB;AACAC,+BAAeW,KAAKC,GAAL,CAASZ,YAAT,EAAuBD,aAAvB,CAAf;AACAE;;AAEAP,oBAAImB,CAAJ,GAAQ,CAAR;AACAnB,oBAAIoB,CAAJ,IAASvB,KAAKwB,UAAd;AACAjB,+BAAe,IAAf;AACA;AACH;;AAED,gBAAII,cAAc,CAAC,CAAf,IAAoB,KAAKhB,QAAL,GAAgB,CAApC,IAAyCQ,IAAImB,CAAJ,GAAQpB,KAAR,GAAgB,KAAKP,QAAlE,EACA;AACIf,qBAAK6C,KAAL,CAAWC,WAAX,CAAuBrB,KAAvB,EAA8BM,SAA9B,EAAyCE,IAAIF,SAA7C;AACAE,oBAAIF,SAAJ;AACAA,4BAAY,CAAC,CAAb;;AAEAL,2BAAWa,IAAX,CAAgBP,cAAhB;AACAH,+BAAeW,KAAKC,GAAL,CAASZ,YAAT,EAAuBG,cAAvB,CAAf;AACAF;;AAEAP,oBAAImB,CAAJ,GAAQ,CAAR;AACAnB,oBAAIoB,CAAJ,IAASvB,KAAKwB,UAAd;AACAjB,+BAAe,IAAf;AACA;AACH;;AAED,gBAAMoB,WAAW3B,KAAKK,KAAL,CAAWU,QAAX,CAAjB;;AAEA,gBAAI,CAACY,QAAL,EACA;AACI;AACH;;AAED,gBAAIpB,gBAAgBoB,SAASC,OAAT,CAAiBrB,YAAjB,CAApB,EACA;AACIJ,oBAAImB,CAAJ,IAASK,SAASC,OAAT,CAAiBrB,YAAjB,CAAT;AACH;;AAEDF,kBAAMc,IAAN,CAAW;AACPU,yBAASF,SAASE,OADX;AAEPnB,0BAFO;AAGPK,kCAHO;AAIPe,0BAAU,IAAIlD,KAAKwB,KAAT,CAAeD,IAAImB,CAAJ,GAAQK,SAASI,OAAhC,EAAyC5B,IAAIoB,CAAJ,GAAQI,SAASK,OAA1D;AAJH,aAAX;AAMAxB,4BAAgBL,IAAImB,CAAJ,IAASK,SAASE,OAAT,CAAiBI,KAAjB,GAAyBN,SAASI,OAA3C,CAAhB;AACA5B,gBAAImB,CAAJ,IAASK,SAASO,QAAlB;AACAtC,4BAAgBwB,KAAKC,GAAL,CAASzB,aAAT,EAAyB+B,SAASK,OAAT,GAAmBL,SAASE,OAAT,CAAiBM,MAA7D,CAAhB;AACA5B,2BAAeQ,QAAf;AACH;;AAEDT,mBAAWa,IAAX,CAAgBX,aAAhB;AACAC,uBAAeW,KAAKC,GAAL,CAASZ,YAAT,EAAuBD,aAAvB,CAAf;;AAEA,YAAM4B,mBAAmB,EAAzB;;AAEA,aAAK,IAAIvB,KAAI,CAAb,EAAgBA,MAAKH,IAArB,EAA2BG,IAA3B,EACA;AACI,gBAAIwB,cAAc,CAAlB;;AAEA,gBAAI,KAAKlD,KAAL,CAAWG,KAAX,KAAqB,OAAzB,EACA;AACI+C,8BAAc5B,eAAeH,WAAWO,EAAX,CAA7B;AACH,aAHD,MAIK,IAAI,KAAK1B,KAAL,CAAWG,KAAX,KAAqB,QAAzB,EACL;AACI+C,8BAAc,CAAC5B,eAAeH,WAAWO,EAAX,CAAhB,IAAiC,CAA/C;AACH;;AAEDuB,6BAAiBjB,IAAjB,CAAsBkB,WAAtB;AACH;;AAED,YAAMC,WAAWjC,MAAMS,MAAvB;AACA,YAAM1B,OAAO,KAAKA,IAAlB;;AAEA,aAAK,IAAIyB,MAAI,CAAb,EAAgBA,MAAIyB,QAApB,EAA8BzB,KAA9B,EACA;AACI,gBAAI0B,IAAI,KAAKrD,OAAL,CAAa2B,GAAb,CAAR,CADJ,CAC6B;;AAEzB,gBAAI0B,CAAJ,EACA;AACIA,kBAAEV,OAAF,GAAYxB,MAAMQ,GAAN,EAASgB,OAArB;AACH,aAHD,MAKA;AACIU,oBAAI,IAAI3D,KAAK4D,MAAT,CAAgBnC,MAAMQ,GAAN,EAASgB,OAAzB,CAAJ;AACA,qBAAK3C,OAAL,CAAaiC,IAAb,CAAkBoB,CAAlB;AACH;;AAEDA,cAAET,QAAF,CAAWR,CAAX,GAAe,CAACjB,MAAMQ,GAAN,EAASiB,QAAT,CAAkBR,CAAlB,GAAsBc,iBAAiB/B,MAAMQ,GAAN,EAASH,IAA1B,CAAvB,IAA0DR,KAAzE;AACAqC,cAAET,QAAF,CAAWP,CAAX,GAAelB,MAAMQ,GAAN,EAASiB,QAAT,CAAkBP,CAAlB,GAAsBrB,KAArC;AACAqC,cAAErC,KAAF,CAAQoB,CAAR,GAAYiB,EAAErC,KAAF,CAAQqB,CAAR,GAAYrB,KAAxB;AACAqC,cAAEnD,IAAF,GAASA,IAAT;;AAEA,gBAAI,CAACmD,EAAEE,MAAP,EACA;AACI,qBAAKC,QAAL,CAAcH,CAAd;AACH;AACJ;;AAED;AACA,aAAK,IAAI1B,MAAIyB,QAAb,EAAuBzB,MAAI,KAAK3B,OAAL,CAAa4B,MAAxC,EAAgD,EAAED,GAAlD,EACA;AACI,iBAAK8B,WAAL,CAAiB,KAAKzD,OAAL,CAAa2B,GAAb,CAAjB;AACH;;AAED,aAAK7B,SAAL,GAAiByB,eAAeP,KAAhC;AACA,aAAKjB,UAAL,GAAkB,CAACkB,IAAIoB,CAAJ,GAAQvB,KAAKwB,UAAd,IAA4BtB,KAA9C;;AAEA;AACA,YAAI,KAAK0C,MAAL,CAAYtB,CAAZ,KAAkB,CAAlB,IAAuB,KAAKsB,MAAL,CAAYrB,CAAZ,KAAkB,CAA7C,EACA;AACI,iBAAK,IAAIV,MAAI,CAAb,EAAgBA,MAAIyB,QAApB,EAA8BzB,KAA9B,EACA;AACI,qBAAK3B,OAAL,CAAa2B,GAAb,EAAgBS,CAAhB,IAAqB,KAAKtC,SAAL,GAAiB,KAAK4D,MAAL,CAAYtB,CAAlD;AACA,qBAAKpC,OAAL,CAAa2B,GAAb,EAAgBU,CAAhB,IAAqB,KAAKtC,UAAL,GAAkB,KAAK2D,MAAL,CAAYrB,CAAnD;AACH;AACJ;AACD,aAAK3B,aAAL,GAAqBA,gBAAgBM,KAArC;AACH,K;;AAED;;;;;;;yBAKA2C,e,8BACA;AACI,aAAKC,QAAL;AACA,aAAKC,wBAAL;AACH,K;;AAED;;;;;;;yBAKAC,c,6BACA;AACI,aAAKF,QAAL;;AAEA,eAAO,0BAAME,cAAN,WAAP;AACH,K;;AAED;;;;;;;yBAKAF,Q,uBACA;AACI,YAAI,KAAKhD,KAAT,EACA;AACI,iBAAKC,UAAL;AACA,iBAAKD,KAAL,GAAa,KAAb;AACH;AACJ,K;;AAED;;;;;;;;;;4BAOA;AACI,mBAAO,KAAKX,KAAL,CAAWC,IAAlB;AACH;;AAED;;;;;;0BAKS6D,K,EACT;AACI,iBAAK9D,KAAL,CAAWC,IAAX,GAAmB,OAAO6D,KAAP,KAAiB,QAAjB,IAA6BA,SAAS,CAAvC,GAA4CA,KAA5C,GAAoD,QAAtE;;AAEA,iBAAKnD,KAAL,GAAa,IAAb;AACH;;AAED;;;;;;;;;;4BAQA;AACI,mBAAO,KAAKX,KAAL,CAAWG,KAAlB;AACH;;AAED;;;;;;0BAKU2D,K,EACV;AACI,iBAAK9D,KAAL,CAAWG,KAAX,GAAmB2D,SAAS,MAA5B;;AAEA,iBAAKnD,KAAL,GAAa,IAAb;AACH;;AAED;;;;;;;;;;;;4BAUA;AACI,mBAAO,KAAKD,OAAZ;AACH;;AAED;;;;;;0BAKWoD,K,EACX;AACI,gBAAI,OAAOA,KAAP,KAAiB,QAArB,EACA;AACI,qBAAKpD,OAAL,CAAaqD,GAAb,CAAiBD,KAAjB;AACH,aAHD,MAKA;AACI,qBAAKpD,OAAL,CAAasD,IAAb,CAAkBF,KAAlB;AACH;AACJ;;AAED;;;;;;;;;4BAOA;AACI,mBAAO,KAAK9D,KAAZ;AACH;;AAED;;;;;;0BAKS8D,K,EACT;AACI,gBAAI,CAACA,KAAL,EACA;AACI;AACH;;AAED,gBAAI,OAAOA,KAAP,KAAiB,QAArB,EACA;AACIA,wBAAQA,MAAMG,KAAN,CAAY,GAAZ,CAAR;;AAEA,qBAAKjE,KAAL,CAAWI,IAAX,GAAkB0D,MAAMnC,MAAN,KAAiB,CAAjB,GAAqBmC,MAAM,CAAN,CAArB,GAAgCA,MAAMI,KAAN,CAAY,CAAZ,EAAeC,IAAf,CAAoB,GAApB,CAAlD;AACA,qBAAKnE,KAAL,CAAWK,IAAX,GAAkByD,MAAMnC,MAAN,IAAgB,CAAhB,GAAoByC,SAASN,MAAM,CAAN,CAAT,EAAmB,EAAnB,CAApB,GAA6CpE,WAAWoB,KAAX,CAAiB,KAAKd,KAAL,CAAWI,IAA5B,EAAkCC,IAAjG;AACH,aAND,MAQA;AACI,qBAAKL,KAAL,CAAWI,IAAX,GAAkB0D,MAAM1D,IAAxB;AACA,qBAAKJ,KAAL,CAAWK,IAAX,GAAkB,OAAOyD,MAAMzD,IAAb,KAAsB,QAAtB,GAAiCyD,MAAMzD,IAAvC,GAA8C+D,SAASN,MAAMzD,IAAf,EAAqB,EAArB,CAAhE;AACH;;AAED,iBAAKM,KAAL,GAAa,IAAb;AACH;;AAED;;;;;;;;;4BAOA;AACI,mBAAO,KAAKJ,KAAZ;AACH;;AAED;;;;;;0BAKSuD,K,EACT;AACIA,oBAAQA,MAAMO,QAAN,MAAoB,GAA5B;AACA,gBAAI,KAAK9D,KAAL,KAAeuD,KAAnB,EACA;AACI;AACH;AACD,iBAAKvD,KAAL,GAAauD,KAAb;AACA,iBAAKnD,KAAL,GAAa,IAAb;AACH;;;;EAvbmClB,KAAK6E,S;;kBAAxB5E,U;;;AA0brBA,WAAWoB,KAAX,GAAmB,EAAnB","file":"BitmapText.js","sourcesContent":["import * as core from '../core';\nimport ObservablePoint from '../core/math/ObservablePoint';\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To\n * split a line you can use '\\n', '\\r' or '\\r\\n' in your string. You can generate the fnt files using:\n *\n * A BitmapText can only be created when the font is loaded\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * let bitmapText = new PIXI.extras.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.extras\n */\nexport default class BitmapText extends core.Container\n{\n    /**\n     * @param {string} text - The copy that you would like the text to display\n     * @param {object} style - The style parameters\n     * @param {string|object} style.font - The font descriptor for the object, can be passed as a string of form\n     *      \"24px FontName\" or \"FontName\" or as an object with explicit name/size properties.\n     * @param {string} [style.font.name] - The bitmap font id\n     * @param {number} [style.font.size] - The size of the font in pixels, e.g. 24\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'), does not affect\n     *      single line text\n     * @param {number} [style.tint=0xFFFFFF] - The tint color\n     */\n    constructor(text, style = {})\n    {\n        super();\n\n        /**\n         * The width of the overall text, different from fontSize,\n         * which is defined in the style object\n         *\n         * @member {number}\n         * @readonly\n         */\n        this.textWidth = 0;\n\n        /**\n         * The height of the overall text, different from fontSize,\n         * which is defined in the style object\n         *\n         * @member {number}\n         * @readonly\n         */\n        this.textHeight = 0;\n\n        /**\n         * Private tracker for the letter sprite pool.\n         *\n         * @member {PIXI.Sprite[]}\n         * @private\n         */\n        this._glyphs = [];\n\n        /**\n         * Private tracker for the current style.\n         *\n         * @member {object}\n         * @private\n         */\n        this._font = {\n            tint: style.tint !== undefined ? style.tint : 0xFFFFFF,\n            align: style.align || 'left',\n            name: null,\n            size: 0,\n        };\n\n        /**\n         * Private tracker for the current font.\n         *\n         * @member {object}\n         * @private\n         */\n        this.font = style.font; // run font setter\n\n        /**\n         * Private tracker for the current text.\n         *\n         * @member {string}\n         * @private\n         */\n        this._text = text;\n\n        /**\n         * The max width of this bitmap text in pixels. If the text provided is longer than the\n         * value provided, line breaks will be automatically inserted in the last whitespace.\n         * Disable by setting value to 0\n         *\n         * @member {number}\n         */\n        this.maxWidth = 0;\n\n        /**\n         * The max line height. This is useful when trying to use the total height of the Text,\n         * ie: when trying to vertically align.\n         *\n         * @member {number}\n         */\n        this.maxLineHeight = 0;\n\n        /**\n         * Text anchor. read-only\n         *\n         * @member {PIXI.ObservablePoint}\n         * @private\n         */\n        this._anchor = new ObservablePoint(() => { this.dirty = true; }, this, 0, 0);\n\n        /**\n         * The dirty state of this object.\n         *\n         * @member {boolean}\n         */\n        this.dirty = false;\n\n        this.updateText();\n    }\n\n    /**\n     * Renders text and updates it when needed\n     *\n     * @private\n     */\n    updateText()\n    {\n        const data = BitmapText.fonts[this._font.name];\n        const scale = this._font.size / data.size;\n        const pos = new core.Point();\n        const chars = [];\n        const lineWidths = [];\n\n        let prevCharCode = null;\n        let lastLineWidth = 0;\n        let maxLineWidth = 0;\n        let line = 0;\n        let lastSpace = -1;\n        let lastSpaceWidth = 0;\n        let maxLineHeight = 0;\n\n        for (let i = 0; i < this.text.length; i++)\n        {\n            const charCode = this.text.charCodeAt(i);\n\n            if (/(\\s)/.test(this.text.charAt(i)))\n            {\n                lastSpace = i;\n                lastSpaceWidth = lastLineWidth;\n            }\n\n            if (/(?:\\r\\n|\\r|\\n)/.test(this.text.charAt(i)))\n            {\n                lineWidths.push(lastLineWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                continue;\n            }\n\n            if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth)\n            {\n                core.utils.removeItems(chars, lastSpace, i - lastSpace);\n                i = lastSpace;\n                lastSpace = -1;\n\n                lineWidths.push(lastSpaceWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastSpaceWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                continue;\n            }\n\n            const charData = data.chars[charCode];\n\n            if (!charData)\n            {\n                continue;\n            }\n\n            if (prevCharCode && charData.kerning[prevCharCode])\n            {\n                pos.x += charData.kerning[prevCharCode];\n            }\n\n            chars.push({\n                texture: charData.texture,\n                line,\n                charCode,\n                position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset),\n            });\n            lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);\n            pos.x += charData.xAdvance;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n        }\n\n        lineWidths.push(lastLineWidth);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n\n        const lineAlignOffsets = [];\n\n        for (let i = 0; i <= line; i++)\n        {\n            let alignOffset = 0;\n\n            if (this._font.align === 'right')\n            {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._font.align === 'center')\n            {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            lineAlignOffsets.push(alignOffset);\n        }\n\n        const lenChars = chars.length;\n        const tint = this.tint;\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            let c = this._glyphs[i]; // get the next glyph sprite\n\n            if (c)\n            {\n                c.texture = chars[i].texture;\n            }\n            else\n            {\n                c = new core.Sprite(chars[i].texture);\n                this._glyphs.push(c);\n            }\n\n            c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n            c.position.y = chars[i].position.y * scale;\n            c.scale.x = c.scale.y = scale;\n            c.tint = tint;\n\n            if (!c.parent)\n            {\n                this.addChild(c);\n            }\n        }\n\n        // remove unnecessary children.\n        for (let i = lenChars; i < this._glyphs.length; ++i)\n        {\n            this.removeChild(this._glyphs[i]);\n        }\n\n        this.textWidth = maxLineWidth * scale;\n        this.textHeight = (pos.y + data.lineHeight) * scale;\n\n        // apply anchor\n        if (this.anchor.x !== 0 || this.anchor.y !== 0)\n        {\n            for (let i = 0; i < lenChars; i++)\n            {\n                this._glyphs[i].x -= this.textWidth * this.anchor.x;\n                this._glyphs[i].y -= this.textHeight * this.anchor.y;\n            }\n        }\n        this.maxLineHeight = maxLineHeight * scale;\n    }\n\n    /**\n     * Updates the transform of this object\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        this.validate();\n        this.containerUpdateTransform();\n    }\n\n    /**\n     * Validates text before calling parent's getLocalBounds\n     *\n     * @return {PIXI.Rectangle} The rectangular bounding area\n     */\n    getLocalBounds()\n    {\n        this.validate();\n\n        return super.getLocalBounds();\n    }\n\n    /**\n     * Updates text when needed\n     *\n     * @private\n     */\n    validate()\n    {\n        if (this.dirty)\n        {\n            this.updateText();\n            this.dirty = false;\n        }\n    }\n\n    /**\n     * The tint of the BitmapText object\n     *\n     * @member {number}\n     * @memberof PIXI.extras.BitmapText#\n     */\n    get tint()\n    {\n        return this._font.tint;\n    }\n\n    /**\n     * Sets the tint.\n     *\n     * @param {number} value - The value to set to.\n     */\n    set tint(value)\n    {\n        this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;\n\n        this.dirty = true;\n    }\n\n    /**\n     * The alignment of the BitmapText object\n     *\n     * @member {string}\n     * @default 'left'\n     * @memberof PIXI.extras.BitmapText#\n     */\n    get align()\n    {\n        return this._font.align;\n    }\n\n    /**\n     * Sets the alignment\n     *\n     * @param {string} value - The value to set to.\n     */\n    set align(value)\n    {\n        this._font.align = value || 'left';\n\n        this.dirty = true;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is 0,0 this means the text's origin is the top left\n     * Setting the anchor to 0.5,0.5 means the text's origin is centered\n     * Setting the anchor to 1,1 would mean the text's origin point will be the bottom right corner\n     *\n     * @member {PIXI.Point | number}\n     * @memberof PIXI.extras.BitmapText#\n     */\n    get anchor()\n    {\n        return this._anchor;\n    }\n\n    /**\n     * Sets the anchor.\n     *\n     * @param {PIXI.Point|number} value - The value to set to.\n     */\n    set anchor(value)\n    {\n        if (typeof value === 'number')\n        {\n            this._anchor.set(value);\n        }\n        else\n        {\n            this._anchor.copy(value);\n        }\n    }\n\n    /**\n     * The font descriptor of the BitmapText object\n     *\n     * @member {string|object}\n     * @memberof PIXI.extras.BitmapText#\n     */\n    get font()\n    {\n        return this._font;\n    }\n\n    /**\n     * Sets the font.\n     *\n     * @param {string|object} value - The value to set to.\n     */\n    set font(value)\n    {\n        if (!value)\n        {\n            return;\n        }\n\n        if (typeof value === 'string')\n        {\n            value = value.split(' ');\n\n            this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');\n            this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;\n        }\n        else\n        {\n            this._font.name = value.name;\n            this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);\n        }\n\n        this.dirty = true;\n    }\n\n    /**\n     * The text of the BitmapText object\n     *\n     * @member {string}\n     * @memberof PIXI.extras.BitmapText#\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    /**\n     * Sets the text.\n     *\n     * @param {string} value - The value to set to.\n     */\n    set text(value)\n    {\n        value = value.toString() || ' ';\n        if (this._text === value)\n        {\n            return;\n        }\n        this._text = value;\n        this.dirty = true;\n    }\n}\n\nBitmapText.fonts = {};\n"]}