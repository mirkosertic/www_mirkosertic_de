{"version":3,"sources":["../../src/mesh/Rope.js"],"names":["core","Rope","texture","points","vertices","Float32Array","length","uvs","colors","indices","Uint16Array","_ready","refresh","_texture","_uvs","textureUvs","offset","Point","x0","y0","factor","x2","y2","x","y","Number","total","i","index","amount","dirty","indexDirty","_onTextureUpdate","updateTransform","lastPoint","nextPoint","perpX","perpY","point","ratio","perpLength","Math","sqrt","num","height","containerUpdateTransform"],"mappings":"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","file":"Rope.js","sourcesContent":["import Mesh from './Mesh';\nimport * as core from '../core';\n\n/**\n * The rope allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let rope = new PIXI.Rope(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.mesh.Mesh\n * @memberof PIXI.mesh\n *\n */\nexport default class Rope extends Mesh\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use on the rope.\n     * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.\n     */\n    constructor(texture, points)\n    {\n        super(texture);\n\n        /*\n         * @member {PIXI.Point[]} An array of points that determine the rope\n         */\n        this.points = points;\n\n        /*\n         * @member {Float32Array} An array of vertices used to construct this rope.\n         */\n        this.vertices = new Float32Array(points.length * 4);\n\n        /*\n         * @member {Float32Array} The WebGL Uvs of the rope.\n         */\n        this.uvs = new Float32Array(points.length * 4);\n\n        /*\n         * @member {Float32Array} An array containing the color components\n         */\n        this.colors = new Float32Array(points.length * 2);\n\n        /*\n         * @member {Uint16Array} An array containing the indices of the vertices\n         */\n        this.indices = new Uint16Array(points.length * 2);\n\n        /**\n         * Tracker for if the rope is ready to be drawn. Needed because Mesh ctor can\n         * call _onTextureUpdated which could call refresh too early.\n         *\n         * @member {boolean}\n         * @private\n         */\n        this._ready = true;\n\n        this.refresh();\n    }\n\n    /**\n     * Refreshes\n     *\n     */\n    refresh()\n    {\n        const points = this.points;\n\n        // if too little points, or texture hasn't got UVs set yet just move on.\n        if (points.length < 1 || !this._texture._uvs)\n        {\n            return;\n        }\n\n        // if the number of points has changed we will need to recreate the arraybuffers\n        if (this.vertices.length / 4 !== points.length)\n        {\n            this.vertices = new Float32Array(points.length * 4);\n            this.uvs = new Float32Array(points.length * 4);\n            this.colors = new Float32Array(points.length * 2);\n            this.indices = new Uint16Array(points.length * 2);\n        }\n\n        const uvs = this.uvs;\n\n        const indices = this.indices;\n        const colors = this.colors;\n\n        const textureUvs = this._texture._uvs;\n        const offset = new core.Point(textureUvs.x0, textureUvs.y0);\n        const factor = new core.Point(textureUvs.x2 - textureUvs.x0, textureUvs.y2 - textureUvs.y0);\n\n        uvs[0] = 0 + offset.x;\n        uvs[1] = 0 + offset.y;\n        uvs[2] = 0 + offset.x;\n        uvs[3] = Number(factor.y) + offset.y;\n\n        colors[0] = 1;\n        colors[1] = 1;\n\n        indices[0] = 0;\n        indices[1] = 1;\n\n        const total = points.length;\n\n        for (let i = 1; i < total; i++)\n        {\n            // time to do some smart drawing!\n            let index = i * 4;\n            const amount = i / (total - 1);\n\n            uvs[index] = (amount * factor.x) + offset.x;\n            uvs[index + 1] = 0 + offset.y;\n\n            uvs[index + 2] = (amount * factor.x) + offset.x;\n            uvs[index + 3] = Number(factor.y) + offset.y;\n\n            index = i * 2;\n            colors[index] = 1;\n            colors[index + 1] = 1;\n\n            index = i * 2;\n            indices[index] = index;\n            indices[index + 1] = index + 1;\n        }\n\n        // ensure that the changes are uploaded\n        this.dirty++;\n        this.indexDirty++;\n    }\n\n    /**\n     * Clear texture UVs when new texture is set\n     *\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        super._onTextureUpdate();\n\n        // wait for the Rope ctor to finish before calling refresh\n        if (this._ready)\n        {\n            this.refresh();\n        }\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        const points = this.points;\n\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        let lastPoint = points[0];\n        let nextPoint;\n        let perpX = 0;\n        let perpY = 0;\n\n        // this.count -= 0.2;\n\n        const vertices = this.vertices;\n        const total = points.length;\n\n        for (let i = 0; i < total; i++)\n        {\n            const point = points[i];\n            const index = i * 4;\n\n            if (i < points.length - 1)\n            {\n                nextPoint = points[i + 1];\n            }\n            else\n            {\n                nextPoint = point;\n            }\n\n            perpY = -(nextPoint.x - lastPoint.x);\n            perpX = nextPoint.y - lastPoint.y;\n\n            let ratio = (1 - (i / (total - 1))) * 10;\n\n            if (ratio > 1)\n            {\n                ratio = 1;\n            }\n\n            const perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));\n            const num = this._texture.height / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n\n            perpX /= perpLength;\n            perpY /= perpLength;\n\n            perpX *= num;\n            perpY *= num;\n\n            vertices[index] = point.x + perpX;\n            vertices[index + 1] = point.y + perpY;\n            vertices[index + 2] = point.x - perpX;\n            vertices[index + 3] = point.y - perpY;\n\n            lastPoint = point;\n        }\n\n        this.containerUpdateTransform();\n    }\n\n}\n"]}