{"version":3,"sources":["../../src/mesh/Mesh.js"],"names":["core","tempPoint","Point","tempPolygon","Polygon","Mesh","texture","vertices","uvs","indices","drawMode","_texture","Float32Array","Uint16Array","dirty","indexDirty","blendMode","BLEND_MODES","NORMAL","canvasPadding","DRAW_MODES","TRIANGLE_MESH","shader","tintRgb","_glDatas","pluginName","_renderWebGL","renderer","setObjectRenderer","plugins","render","_renderCanvas","_onTextureUpdate","_calculateBounds","_bounds","addVertices","transform","length","containsPoint","point","getBounds","contains","x","y","worldTransform","applyInverse","points","len","step","TRIANGLES","i","ind0","ind1","ind2","value","baseTexture","hasLoaded","once","utils","rgb2hex","hex2rgb","Container"],"mappings":"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","file":"Mesh.js","sourcesContent":["import * as core from '../core';\n\nconst tempPoint = new core.Point();\nconst tempPolygon = new core.Polygon();\n\n/**\n * Base mesh class\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n */\nexport default class Mesh extends core.Container\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use\n     * @param {Float32Array} [vertices] - if you want to specify the vertices\n     * @param {Float32Array} [uvs] - if you want to specify the uvs\n     * @param {Uint16Array} [indices] - if you want to specify the indices\n     * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts\n     */\n    constructor(texture, vertices, uvs, indices, drawMode)\n    {\n        super();\n\n        /**\n         * The texture of the Mesh\n         *\n         * @member {PIXI.Texture}\n         * @private\n         */\n        this._texture = null;\n\n        /**\n         * The Uvs of the Mesh\n         *\n         * @member {Float32Array}\n         */\n        this.uvs = uvs || new Float32Array([0, 0,\n            1, 0,\n            1, 1,\n            0, 1]);\n\n        /**\n         * An array of vertices\n         *\n         * @member {Float32Array}\n         */\n        this.vertices = vertices || new Float32Array([0, 0,\n            100, 0,\n            100, 100,\n            0, 100]);\n\n        /*\n         * @member {Uint16Array} An array containing the indices of the vertices\n         */\n        //  TODO auto generate this based on draw mode!\n        this.indices = indices || new Uint16Array([0, 1, 3, 2]);\n\n        /**\n         * Version of mesh uvs are dirty or not\n         *\n         * @member {number}\n         */\n        this.dirty = 0;\n\n        /**\n         * Version of mesh indices\n         *\n         * @member {number}\n         */\n        this.indexDirty = 0;\n\n        /**\n         * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove\n         * any blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = core.BLEND_MODES.NORMAL;\n\n        /**\n         * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n         * to overlap a bit with each other.\n         *\n         * @member {number}\n         */\n        this.canvasPadding = 0;\n\n        /**\n         * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts\n         *\n         * @member {number}\n         * @see PIXI.mesh.Mesh.DRAW_MODES\n         */\n        this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;\n\n        // run texture setter;\n        this.texture = texture;\n\n        /**\n         * The default shader that is used if a mesh doesn't have a more specific one.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        /**\n         * The tint applied to the mesh. This is a [r,g,b] value. A value of [1,1,1] will remove any\n         * tint effect.\n         *\n         * @member {number}\n         * @memberof PIXI.mesh.Mesh#\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n\n        /**\n         * A map of renderer IDs to webgl render data\n         *\n         * @private\n         * @member {object<number, object>}\n         */\n        this._glDatas = {};\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.\n         *\n         * @member {string}\n         * @default 'mesh'\n         */\n        this.pluginName = 'mesh';\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - a reference to the WebGL renderer\n     */\n    _renderWebGL(renderer)\n    {\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n     */\n    _renderCanvas(renderer)\n    {\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * When the texture is updated, this event will fire to update the scale and frame\n     *\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        /* empty */\n    }\n\n    /**\n     * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     *\n     */\n    _calculateBounds()\n    {\n        // TODO - we can cache local bounds and use them if they are dirty (like graphics)\n        this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length);\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.vertices;\n        const points = tempPolygon.points;\n        const indices = this.indices;\n        const len = this.indices.length;\n        const step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * The texture that the mesh uses.\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.mesh.Mesh#\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * Sets the texture the mesh uses.\n     *\n     * @param {Texture} value - The value to set.\n     */\n    set texture(value)\n    {\n        if (this._texture === value)\n        {\n            return;\n        }\n\n        this._texture = value;\n\n        if (value)\n        {\n            // wait for the texture to load\n            if (value.baseTexture.hasLoaded)\n            {\n                this._onTextureUpdate();\n            }\n            else\n            {\n                value.once('update', this._onTextureUpdate, this);\n            }\n        }\n    }\n\n    /**\n     * The tint applied to the mesh. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @memberof PIXI.mesh.Mesh#\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return core.utils.rgb2hex(this.tintRgb);\n    }\n\n    /**\n     * Sets the tint the mesh uses.\n     *\n     * @param {number} value - The value to set.\n     */\n    set tint(value)\n    {\n        this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);\n    }\n}\n\n/**\n * Different drawing buffer modes supported\n *\n * @static\n * @constant\n * @type {object}\n * @property {number} TRIANGLE_MESH\n * @property {number} TRIANGLES\n */\nMesh.DRAW_MODES = {\n    TRIANGLE_MESH: 0,\n    TRIANGLES: 1,\n};\n"]}