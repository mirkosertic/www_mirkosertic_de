{"version":3,"sources":["../../../../src/core/sprites/canvas/CanvasTinter.js"],"names":["CanvasTinter","getTintedTexture","sprite","color","texture","roundColor","stringColor","toString","substr","tintCache","canvas","document","createElement","tintMethod","convertTintToImage","tintImage","Image","src","toDataURL","tintWithMultiply","context","getContext","crop","_frame","clone","resolution","baseTexture","x","y","width","height","fillStyle","fillRect","globalCompositeOperation","drawImage","source","tintWithOverlay","tintWithPerPixel","rgbValues","r","g","b","pixelData","getImageData","pixels","data","i","length","putImageData","step","cacheStepsPerColorChannel","Math","min","canUseMultiply"],"mappings":"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","file":"CanvasTinter.js","sourcesContent":["import { hex2rgb, rgb2hex } from '../../utils';\nimport canUseNewCanvasBlendModes from '../../renderers/canvas/utils/canUseNewCanvasBlendModes';\n\n/**\n * Utility methods for Sprite/Texture tinting.\n *\n * @namespace PIXI.CanvasTinter\n */\nconst CanvasTinter = {\n    /**\n     * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Sprite} sprite - the sprite to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @return {HTMLCanvasElement} The tinted canvas\n     */\n    getTintedTexture: (sprite, color) =>\n    {\n        const texture = sprite.texture;\n\n        color = CanvasTinter.roundColor(color);\n\n        const stringColor = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n\n        texture.tintCache = texture.tintCache || {};\n\n        if (texture.tintCache[stringColor])\n        {\n            return texture.tintCache[stringColor];\n        }\n\n        // clone texture..\n        const canvas = CanvasTinter.canvas || document.createElement('canvas');\n\n        // CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);\n        CanvasTinter.tintMethod(texture, color, canvas);\n\n        if (CanvasTinter.convertTintToImage)\n        {\n            // is this better?\n            const tintImage = new Image();\n\n            tintImage.src = canvas.toDataURL();\n\n            texture.tintCache[stringColor] = tintImage;\n        }\n        else\n        {\n            texture.tintCache[stringColor] = canvas;\n            // if we are not converting the texture to an image then we need to lose the reference to the canvas\n            CanvasTinter.canvas = null;\n        }\n\n        return canvas;\n    },\n\n    /**\n     * Tint a texture using the 'multiply' operation.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithMultiply: (texture, color, canvas) =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = crop.width;\n        canvas.height = crop.height;\n\n        context.fillStyle = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n\n        context.fillRect(0, 0, crop.width, crop.height);\n\n        context.globalCompositeOperation = 'multiply';\n\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        context.globalCompositeOperation = 'destination-atop';\n\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n    },\n\n    /**\n     * Tint a texture using the 'overlay' operation.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithOverlay(texture, color, canvas)\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = crop.width;\n        canvas.height = crop.height;\n\n        context.globalCompositeOperation = 'copy';\n        context.fillStyle = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n        context.fillRect(0, 0, crop.width, crop.height);\n\n        context.globalCompositeOperation = 'destination-atop';\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        // context.globalCompositeOperation = 'copy';\n    },\n\n    /**\n     * Tint a texture pixel per pixel.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithPerPixel: (texture, color, canvas) =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = crop.width;\n        canvas.height = crop.height;\n\n        context.globalCompositeOperation = 'copy';\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        const rgbValues = hex2rgb(color);\n        const r = rgbValues[0];\n        const g = rgbValues[1];\n        const b = rgbValues[2];\n\n        const pixelData = context.getImageData(0, 0, crop.width, crop.height);\n\n        const pixels = pixelData.data;\n\n        for (let i = 0; i < pixels.length; i += 4)\n        {\n            pixels[i + 0] *= r;\n            pixels[i + 1] *= g;\n            pixels[i + 2] *= b;\n        }\n\n        context.putImageData(pixelData, 0, 0);\n    },\n\n    /**\n     * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {number} color - the color to round, should be a hex color\n     * @return {number} The rounded color.\n     */\n    roundColor: (color) =>\n    {\n        const step = CanvasTinter.cacheStepsPerColorChannel;\n\n        const rgbValues = hex2rgb(color);\n\n        rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);\n        rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);\n        rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);\n\n        return rgb2hex(rgbValues);\n    },\n\n    /**\n     * Number of steps which will be used as a cap when rounding colors.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {number}\n     */\n    cacheStepsPerColorChannel: 8,\n\n    /**\n     * Tint cache boolean flag.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {boolean}\n     */\n    convertTintToImage: false,\n\n    /**\n     * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {boolean}\n     */\n    canUseMultiply: canUseNewCanvasBlendModes(),\n\n    /**\n     * The tinting method that will be used.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {tintMethodFunctionType}\n     */\n    tintMethod: 0,\n};\n\nCanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;\n\n/**\n * The tintMethod type.\n *\n * @memberof PIXI.CanvasTinter\n * @callback tintMethodFunctionType\n * @param texture {PIXI.Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\n\nexport default CanvasTinter;\n"]}