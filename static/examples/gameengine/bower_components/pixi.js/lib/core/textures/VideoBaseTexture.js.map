{"version":3,"sources":["../../../src/core/textures/VideoBaseTexture.js"],"names":["ticker","VideoBaseTexture","source","scaleMode","Error","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","width","height","complete","videoWidth","videoHeight","_autoUpdate","_isAutoUpdating","autoPlay","update","bind","_onCanPlay","addEventListener","_onPlayStart","_onPlayStop","hasLoaded","__loaded","_isSourceReady","_isSourcePlaying","currentTime","paused","ended","autoUpdate","shared","add","remove","removeEventListener","emit","play","destroy","_pixiId","fromVideo","video","baseTexture","fromUrl","videoSrc","document","createElement","setAttribute","Array","isArray","i","length","appendChild","createSource","src","mime","load","value","fromUrls","path","type","substr","lastIndexOf"],"mappings":"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","file":"VideoBaseTexture.js","sourcesContent":["import BaseTexture from './BaseTexture';\nimport { uid, BaseTextureCache } from '../utils';\nimport * as ticker from '../ticker';\n\n/**\n * A texture of a [playing] Video.\n *\n * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.\n *\n * This can be used in several ways, such as:\n *\n * ```js\n * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');\n *\n * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls([\n *     { src: '/video.webm', mime: 'video/webm' },\n *     { src: '/video.mp4', mime: 'video/mp4' }\n * ]);\n * ```\n *\n * See the [\"deus\" demo](http://www.goodboydigital.com/pixijs/examples/deus/).\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\nexport default class VideoBaseTexture extends BaseTexture\n{\n    /**\n     * @param {HTMLVideoElement} source - Video source\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     */\n    constructor(source, scaleMode)\n    {\n        if (!source)\n        {\n            throw new Error('No video source element specified.');\n        }\n\n        // hook in here to check if video is already available.\n        // BaseTexture looks for a source.complete boolean, plus width & height.\n\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            source.complete = true;\n        }\n\n        super(source, scaleMode);\n\n        this.width = source.videoWidth;\n        this.height = source.videoHeight;\n\n        this._autoUpdate = true;\n        this._isAutoUpdating = false;\n\n        /**\n         * When set to true will automatically play videos used by this texture once\n         * they are loaded. If false, it will not modify the playing state.\n         *\n         * @member {boolean}\n         * @default true\n         */\n        this.autoPlay = true;\n\n        this.update = this.update.bind(this);\n        this._onCanPlay = this._onCanPlay.bind(this);\n\n        source.addEventListener('play', this._onPlayStart.bind(this));\n        source.addEventListener('pause', this._onPlayStop.bind(this));\n        this.hasLoaded = false;\n        this.__loaded = false;\n\n        if (!this._isSourceReady())\n        {\n            source.addEventListener('canplay', this._onCanPlay);\n            source.addEventListener('canplaythrough', this._onCanPlay);\n        }\n        else\n        {\n            this._onCanPlay();\n        }\n    }\n\n    /**\n     * Returns true if the underlying source is playing.\n     *\n     * @private\n     * @return {boolean} True if playing.\n     */\n    _isSourcePlaying()\n    {\n        const source = this.source;\n\n        return (source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2);\n    }\n\n    /**\n     * Returns true if the underlying source is ready for playing.\n     *\n     * @private\n     * @return {boolean} True if ready.\n     */\n    _isSourceReady()\n    {\n        return this.source.readyState === 3 || this.source.readyState === 4;\n    }\n\n    /**\n     * Runs the update loop when the video is ready to play\n     *\n     * @private\n     */\n    _onPlayStart()\n    {\n        // Just in case the video has not received its can play even yet..\n        if (!this.hasLoaded)\n        {\n            this._onCanPlay();\n        }\n\n        if (!this._isAutoUpdating && this.autoUpdate)\n        {\n            ticker.shared.add(this.update, this);\n            this._isAutoUpdating = true;\n        }\n    }\n\n    /**\n     * Fired when a pause event is triggered, stops the update loop\n     *\n     * @private\n     */\n    _onPlayStop()\n    {\n        if (this._isAutoUpdating)\n        {\n            ticker.shared.remove(this.update, this);\n            this._isAutoUpdating = false;\n        }\n    }\n\n    /**\n     * Fired when the video is loaded and ready to play\n     *\n     * @private\n     */\n    _onCanPlay()\n    {\n        this.hasLoaded = true;\n\n        if (this.source)\n        {\n            this.source.removeEventListener('canplay', this._onCanPlay);\n            this.source.removeEventListener('canplaythrough', this._onCanPlay);\n\n            this.width = this.source.videoWidth;\n            this.height = this.source.videoHeight;\n\n            // prevent multiple loaded dispatches..\n            if (!this.__loaded)\n            {\n                this.__loaded = true;\n                this.emit('loaded', this);\n            }\n\n            if (this._isSourcePlaying())\n            {\n                this._onPlayStart();\n            }\n            else if (this.autoPlay)\n            {\n                this.source.play();\n            }\n        }\n    }\n\n    /**\n     * Destroys this texture\n     *\n     */\n    destroy()\n    {\n        if (this._isAutoUpdating)\n        {\n            ticker.shared.remove(this.update, this);\n        }\n\n        if (this.source && this.source._pixiId)\n        {\n            delete BaseTextureCache[this.source._pixiId];\n            delete this.source._pixiId;\n        }\n\n        super.destroy();\n    }\n\n    /**\n     * Mimic Pixi BaseTexture.from.... method.\n     *\n     * @static\n     * @param {HTMLVideoElement} video - Video to create texture from\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n     */\n    static fromVideo(video, scaleMode)\n    {\n        if (!video._pixiId)\n        {\n            video._pixiId = `video_${uid()}`;\n        }\n\n        let baseTexture = BaseTextureCache[video._pixiId];\n\n        if (!baseTexture)\n        {\n            baseTexture = new VideoBaseTexture(video, scaleMode);\n            BaseTextureCache[video._pixiId] = baseTexture;\n        }\n\n        return baseTexture;\n    }\n\n    /**\n     * Helper function that creates a new BaseTexture based on the given video element.\n     * This BaseTexture can then be used to create a texture\n     *\n     * @static\n     * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.\n     * @param {string} [videoSrc.src] - One of the source urls for the video\n     * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified\n     *  the url's extension will be used as the second part of the mime type.\n     * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values\n     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n     */\n    static fromUrl(videoSrc, scaleMode)\n    {\n        const video = document.createElement('video');\n\n        video.setAttribute('webkit-playsinline', '');\n        video.setAttribute('playsinline', '');\n\n        // array of objects or strings\n        if (Array.isArray(videoSrc))\n        {\n            for (let i = 0; i < videoSrc.length; ++i)\n            {\n                video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));\n            }\n        }\n        // single object or string\n        else\n        {\n            video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));\n        }\n\n        video.load();\n\n        return VideoBaseTexture.fromVideo(video, scaleMode);\n    }\n\n    /**\n     * Should the base texture automatically update itself, set to true by default\n     *\n     * @member {boolean}\n     * @memberof PIXI.VideoBaseTexture#\n     */\n    get autoUpdate()\n    {\n        return this._autoUpdate;\n    }\n\n    /**\n     * Sets autoUpdate property.\n     *\n     * @param {number} value - enable auto update or not\n     */\n    set autoUpdate(value)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isAutoUpdating)\n            {\n                ticker.shared.remove(this.update, this);\n                this._isAutoUpdating = false;\n            }\n            else if (this._autoUpdate && !this._isAutoUpdating)\n            {\n                ticker.shared.add(this.update, this);\n                this._isAutoUpdating = true;\n            }\n        }\n    }\n}\n\nVideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;\n\nfunction createSource(path, type)\n{\n    if (!type)\n    {\n        type = `video/${path.substr(path.lastIndexOf('.') + 1)}`;\n    }\n\n    const source = document.createElement('source');\n\n    source.src = path;\n    source.type = type;\n\n    return source;\n}\n"]}