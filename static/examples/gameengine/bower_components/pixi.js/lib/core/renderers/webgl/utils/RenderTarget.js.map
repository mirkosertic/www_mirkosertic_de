{"version":3,"sources":["../../../../../src/core/renderers/webgl/utils/RenderTarget.js"],"names":["RenderTarget","gl","width","height","scaleMode","resolution","root","frameBuffer","texture","clearColor","size","RESOLUTION","projectionMatrix","transform","frame","defaultFrame","destinationFrame","sourceFrame","stencilBuffer","stencilMaskStack","filterData","SCALE_MODE","createRGBA","NEAREST","enableNearestScaling","enableLinearScaling","framebuffer","setFrame","resize","clear","cc","attachStencilBuffer","enableStencil","activate","bind","calculateProjection","append","enable","SCISSOR_TEST","scissor","x","y","disable","viewport","pm","identity","a","d","tx","ty","projectionFrame","destroy"],"mappings":"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","file":"RenderTarget.js","sourcesContent":["import { Rectangle, Matrix } from '../../../math';\nimport { SCALE_MODES } from '../../../const';\nimport settings from '../../../settings';\nimport { GLFramebuffer } from 'pixi-gl-core';\n\n/**\n * @class\n * @memberof PIXI\n */\nexport default class RenderTarget\n{\n    /**\n     * @param {WebGLRenderingContext} gl - The current WebGL drawing context\n     * @param {number} [width=0] - the horizontal range of the filter\n     * @param {number} [height=0] - the vertical range of the filter\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [resolution=1] - The current resolution / device pixel ratio\n     * @param {boolean} [root=false] - Whether this object is the root element or not\n     */\n    constructor(gl, width, height, scaleMode, resolution, root)\n    {\n        // TODO Resolution could go here ( eg low res blurs )\n\n        /**\n         * The current WebGL drawing context.\n         *\n         * @member {WebGLRenderingContext}\n         */\n        this.gl = gl;\n\n        // next time to create a frame buffer and texture\n\n        /**\n         * A frame buffer\n         *\n         * @member {PIXI.glCore.GLFramebuffer}\n         */\n        this.frameBuffer = null;\n\n        /**\n         * The texture\n         *\n         * @member {PIXI.glCore.GLTexture}\n         */\n        this.texture = null;\n\n        /**\n         * The background colour of this render target, as an array of [r,g,b,a] values\n         *\n         * @member {number[]}\n         */\n        this.clearColor = [0, 0, 0, 0];\n\n        /**\n         * The size of the object as a rectangle\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.size = new Rectangle(0, 0, 1, 1);\n\n        /**\n         * The current resolution / device pixel ratio\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.resolution = resolution || settings.RESOLUTION;\n\n        /**\n         * The projection matrix\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.projectionMatrix = new Matrix();\n\n        /**\n         * The object's transform\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.transform = null;\n\n        /**\n         * The frame.\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.frame = null;\n\n        /**\n         * The stencil buffer stores masking data for the render target\n         *\n         * @member {glCore.GLBuffer}\n         */\n        this.defaultFrame = new Rectangle();\n        this.destinationFrame = null;\n        this.sourceFrame = null;\n\n        /**\n         * The stencil buffer stores masking data for the render target\n         *\n         * @member {glCore.GLBuffer}\n         */\n        this.stencilBuffer = null;\n\n        /**\n         * The data structure for the stencil masks\n         *\n         * @member {PIXI.Graphics[]}\n         */\n        this.stencilMaskStack = [];\n\n        /**\n         * Stores filter data for the render target\n         *\n         * @member {object[]}\n         */\n        this.filterData = null;\n\n        /**\n         * The scale mode.\n         *\n         * @member {number}\n         * @default PIXI.settings.SCALE_MODE\n         * @see PIXI.SCALE_MODES\n         */\n        this.scaleMode = scaleMode || settings.SCALE_MODE;\n\n        /**\n         * Whether this object is the root element or not\n         *\n         * @member {boolean}\n         */\n        this.root = root;\n\n        if (!this.root)\n        {\n            this.frameBuffer = GLFramebuffer.createRGBA(gl, 100, 100);\n\n            if (this.scaleMode === SCALE_MODES.NEAREST)\n            {\n                this.frameBuffer.texture.enableNearestScaling();\n            }\n            else\n            {\n                this.frameBuffer.texture.enableLinearScaling();\n            }\n            /*\n                A frame buffer needs a target to render to..\n                create a texture and bind it attach it to the framebuffer..\n             */\n\n            // this is used by the base texture\n            this.texture = this.frameBuffer.texture;\n        }\n        else\n        {\n            // make it a null framebuffer..\n            this.frameBuffer = new GLFramebuffer(gl, 100, 100);\n            this.frameBuffer.framebuffer = null;\n        }\n\n        this.setFrame();\n\n        this.resize(width, height);\n    }\n\n    /**\n     * Clears the filter texture.\n     *\n     * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer\n     */\n    clear(clearColor)\n    {\n        const cc = clearColor || this.clearColor;\n\n        this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]);// r,g,b,a);\n    }\n\n    /**\n     * Binds the stencil buffer.\n     *\n     */\n    attachStencilBuffer()\n    {\n        // TODO check if stencil is done?\n        /**\n         * The stencil buffer is used for masking in pixi\n         * lets create one and then add attach it to the framebuffer..\n         */\n        if (!this.root)\n        {\n            this.frameBuffer.enableStencil();\n        }\n    }\n\n    /**\n     * Sets the frame of the render target.\n     *\n     * @param {Rectangle} destinationFrame - The destination frame.\n     * @param {Rectangle} sourceFrame - The source frame.\n     */\n    setFrame(destinationFrame, sourceFrame)\n    {\n        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;\n        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;\n    }\n\n    /**\n     * Binds the buffers and initialises the viewport.\n     *\n     */\n    activate()\n    {\n        // TOOD refactor usage of frame..\n        const gl = this.gl;\n\n        // make sure the texture is unbound!\n        this.frameBuffer.bind();\n\n        this.calculateProjection(this.destinationFrame, this.sourceFrame);\n\n        if (this.transform)\n        {\n            this.projectionMatrix.append(this.transform);\n        }\n\n        // TODO add a check as them may be the same!\n        if (this.destinationFrame !== this.sourceFrame)\n        {\n            gl.enable(gl.SCISSOR_TEST);\n            gl.scissor(\n                this.destinationFrame.x | 0,\n                this.destinationFrame.y | 0,\n                (this.destinationFrame.width * this.resolution) | 0,\n                (this.destinationFrame.height * this.resolution) | 0\n            );\n        }\n        else\n        {\n            gl.disable(gl.SCISSOR_TEST);\n        }\n\n        // TODO - does not need to be updated all the time??\n        gl.viewport(\n            this.destinationFrame.x | 0,\n            this.destinationFrame.y | 0,\n            (this.destinationFrame.width * this.resolution) | 0,\n            (this.destinationFrame.height * this.resolution) | 0\n        );\n    }\n\n    /**\n     * Updates the projection matrix based on a projection frame (which is a rectangle)\n     *\n     * @param {Rectangle} destinationFrame - The destination frame.\n     * @param {Rectangle} sourceFrame - The source frame.\n     */\n    calculateProjection(destinationFrame, sourceFrame)\n    {\n        const pm = this.projectionMatrix;\n\n        sourceFrame = sourceFrame || destinationFrame;\n\n        pm.identity();\n\n        // TODO: make dest scale source\n        if (!this.root)\n        {\n            pm.a = 1 / destinationFrame.width * 2;\n            pm.d = 1 / destinationFrame.height * 2;\n\n            pm.tx = -1 - (sourceFrame.x * pm.a);\n            pm.ty = -1 - (sourceFrame.y * pm.d);\n        }\n        else\n        {\n            pm.a = 1 / destinationFrame.width * 2;\n            pm.d = -1 / destinationFrame.height * 2;\n\n            pm.tx = -1 - (sourceFrame.x * pm.a);\n            pm.ty = 1 - (sourceFrame.y * pm.d);\n        }\n    }\n\n    /**\n     * Resizes the texture to the specified width and height\n     *\n     * @param {number} width - the new width of the texture\n     * @param {number} height - the new height of the texture\n     */\n    resize(width, height)\n    {\n        width = width | 0;\n        height = height | 0;\n\n        if (this.size.width === width && this.size.height === height)\n        {\n            return;\n        }\n\n        this.size.width = width;\n        this.size.height = height;\n\n        this.defaultFrame.width = width;\n        this.defaultFrame.height = height;\n\n        this.frameBuffer.resize(width * this.resolution, height * this.resolution);\n\n        const projectionFrame = this.frame || this.size;\n\n        this.calculateProjection(projectionFrame);\n    }\n\n    /**\n     * Destroys the render target.\n     *\n     */\n    destroy()\n    {\n        this.frameBuffer.destroy();\n\n        this.frameBuffer = null;\n        this.texture = null;\n    }\n}\n"]}