+++
date = "2017-02-12T00:00:00+01:00"
title = "Service integration at UI level with server side includes(SSI)"
tags = ["Domain-driven Design", "Integration", "User Interface", "Enterprise"]
draft = true
+++
include::globals.adoc[]

== Microservices everywhere

Today, https://en.wikipedia.org/wiki/Microservices[Microservices] are a common software modeling technique. This style is based on the principles behind
https://en.wikipedia.org/wiki/Domain-driven_design[Domain-driven Design], where every bounded context is equivalent to
a service. If we also take the https://12factor.net[Twelve-Factor App] manifesto into consideration, we able to create scalable
and cloud ready systems.

But this design can also lead to problems. If we take the Microservice design too far(https://en.wikipedia.org/wiki/Microservices[Nanoservices]), we are quickly getting way to
much services we can handle and maintain. There is also the risk that we are somehow violating the original bounded context
for our services, leading to lack of responsibility and functional encapsulation. Maybe the Microservices could degenerate to some
kind of remote data access object. If we do not respect the principle of independently deployable units, we would be quickly creating
a distributed, complex and very slow monolith.

== Rethinking the architecture

Well, what can we do? The problem can be the vast amount of services in our architecture, which also increases the number of interfaces we have
to support and maintain. So the solution might be to create fewer services, and not more! We create a system for every bounded context, and include
everything in this system, from database to application logic and even the user interface. This architecture style is called a
http://scs-architecture.org[Self-Contained System], and it is in fact the oposite of Nanoservices. SCS means Self-Contained System, not
Self-Contained Service. So it can include one-to-many services, but as as argued above, it is a good idea to keep the number of services small,
even inside a SCS. Every SCS provices a user interface, which can be anything, from RESTful APIs to a full blown HTML frontend(i will come to this later).

Now, what is a SCS-Architecture? Basically it looks as follows:

[ditaa,scsarchitecture]
----
+---------------------------------+  +---------------------------------+
| SCS for Bounded Context 1       |  | SCS for Bounded Context 2..n    |
|                                 |  |                                 |
|  +----------------+----------+  |  |  +----------------+----------+  |
|  | User-Interface | API      |  |  |  | User-Interface | API      |  |
|  +----------------+----------+  |  |  +----------------+----------+  |
|  | Service(s)                |  |  |  | Service(s)                |  |
|  +--------------+------------+  |  |  +--------------+------------+  |
|                 |               |  |                 |               |
|           +-----+-----+         |  |           +-----+-----+         |
|           | Database  |         |  |           | Database  |         |
|           | {s}       |         |  |           | {s}       |         |
|           +-----------+         |  |           +-----------+         |
+---------------------------------+  +---------------------------------+
----


== Integration patterns and data management

== Common caveats

== Conclusion

