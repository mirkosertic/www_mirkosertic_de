+++
date = "2017-02-12T00:00:00+01:00"
title = "Service integration at UI level with server side includes(SSI)"
tags = ["Domain-driven Design", "Integration", "User Interface", "Enterprise"]
draft = true
+++
include::globals.adoc[]

== Microservices everywhere

Today, https://en.wikipedia.org/wiki/Microservices[Microservices] are a common software modeling technique. This style is based on the principles behind
https://en.wikipedia.org/wiki/Domain-driven_design[Domain-driven Design], where every bounded context is equivalent to
a service. If we also take the https://12factor.net[Twelve-Factor App] manifesto into consideration, we able to create scalable
and cloud ready systems.

But this design can also lead to problems. If we take the Microservice design too far(https://en.wikipedia.org/wiki/Microservices[Nanoservices]), we are quickly getting way to
much services we can handle and maintain. There is also the risk that we are somehow violating the original bounded context
for our services, leading to lack of responsibility and functional encapsulation. Maybe the Microservices could degenerate to some
kind of remote data access object. If we do not respect the principle of independently deployable units, we would be quickly creating
a distributed, complex and very slow monolith.

== Rethinking the architecture

Well, what can we do? The problem can be the vast amount of services in our architecture, which also increases the number of interfaces we have
to support and maintain. So the solution might be to create fewer services, and not more! We create a system for every bounded context(see my link:{{< ref "domain-driven-design-example.adoc" >}}[A Domain-driven Design Example] to get in touch with Domain-driven Design), and include
everything in this system, from database to application logic and even the user interface. This architecture style is called a
http://scs-architecture.org[Self-Contained System], and it is in fact the oposite of Nanoservices. SCS means Self-Contained System, not
Self-Contained Service. So it can include one-to-many services, but as as argued above, it is a good idea to keep the number of services small,
even inside a SCS. Every SCS provices a user interface, which can be anything, from RESTful APIs to a full blown HTML frontend(i will come to this later).

Now, what is a SCS-Architecture? Basically it looks as follows:

[ditaa,scsarchitecture]
----
+---------------------------------+            +---------------------------------+
| SCS for Bounded Context 1       |            | SCS for Bounded Context 2..n    |
|                                 |            |                                 |
|  +----------------+----------+  |            |  +----------------+----------+  |
|  | User-Interface | API      |  |            |  | User-Interface | API      |  |
|  +----------------+----------+  |            |  +----------------+----------+  |
|  | Service(s)                |  +<- Events ->+  | Service(s)                |  |
|  +--------------+------------+  |            |  +--------------+------------+  |
|                 |               |            |                 |               |
|           +-----+-----+         |            |           +-----+-----+         |
|           | Database  |         |            |           | Database  |         |
|           | {s}       |         |            |           | {s}       |         |
|           +-----------+         |            |           +-----------+         |
+---------------------------------+            +---------------------------------+
----

Every SCS represents a bounded context with its own ubiquitous language. The main goal
is to keep the SCS independent of each other to reduce deployment complexity and make them
exchangeable. Every SCS is developed and maintained by exactly one team to reduce development
and project management friction.

The interesting point here is that a SCS is in fact a standalone application. It contains
everything, from user interface to database, just everything that is needed to fulfill the
requirements of its bounded context.

== User interface integration patterns



== Common issues

== Conclusion

