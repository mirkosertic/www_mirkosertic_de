+++
date = "2017-02-12T00:00:00+01:00"
title = "Service integration at UI level with server side includes(SSI)"
tags = ["Domain-driven Design", "Integration", "User Interface", "Enterprise"]
draft = true
+++
include::globals.adoc[]

== Microservices everywhere

Today, https://en.wikipedia.org/wiki/Microservices[Microservices] are a common software modeling technique. This style is based on the principles behind
https://en.wikipedia.org/wiki/Domain-driven_design[Domain-driven Design], where every bounded context is equivalent to
a service. If we also take the https://12factor.net[Twelve-Factor App] manifesto into consideration, we able to create scalable
and cloud ready systems.

But this design can also lead to problems. If we take the Microservice design too far(https://en.wikipedia.org/wiki/Microservices[Nanoservices]), we are quickly getting way to
much services we can handle and maintain. There is also the risk that we are somehow violating the original bounded context
for our services, leading to lack of responsibility and functional encapsulation. Maybe the Microservices could degenerate to some
kind of remote data access object. If we do not respect the principle of independently deployable units, we would be quickly creating
a distributed, complex and very slow monolith.

== Rethinking the architecture

Well, what can we do? The problem can be the vast amount of services in our architecture, which also increases the number of interfaces we have
to support and maintain. So the solution might be to create fewer services, and not more! We create a system for every bounded context(see my link:{{< ref "domain-driven-design-example.adoc" >}}[A Domain-driven Design Example] to get in touch with Domain-driven Design), and include
everything in this system, from database to application logic and even the user interface. This architecture style is called a
http://scs-architecture.org[Self-Contained System], and it is in fact the oposite of Nanoservices. SCS means Self-Contained System, not
Self-Contained Service. So it can include one-to-many services, but as as argued above, it is a good idea to keep the number of services small,
even inside a SCS. Every SCS provices a user interface, which can be anything, from RESTful APIs to a full blown HTML frontend(i will come to this later).

Now, what is a SCS-Architecture? Basically it looks as follows:

[ditaa,scsarchitecture]
----
+---------------------------------+            +---------------------------------+
| SCS for Bounded Context 1       |            | SCS for Bounded Context 2..n    |
|                                 |            |                                 |
|  +----------------------+----+  |            |  +----------------------+----+  |
|  | User-Interface       | API|  |            |  | User-Interface       | API|  |
|  +----------------------+----+  |            |  +----------------------+----+  |
|  | Service(s)                |  +<- Events ->+  | Service(s)                |  |
|  +--------------+------------+  |            |  +--------------+------------+  |
|                 |               |            |                 |               |
|           +-----+-----+         |            |           +-----+-----+         |
|           | Database  |         |            |           | Database  |         |
|           |           |         |            |           |           |         |
|           +-----------+         |            |           +-----------+         |
+---------------------------------+            +---------------------------------+
----

Every SCS represents a bounded context with its own ubiquitous language. The main goal
is to keep the SCS independent of each other to reduce deployment complexity and make them
exchangeable. Every SCS is developed and maintained by exactly one team to reduce development
and project management friction.

Every SCS needs some kind of interface for its clients. It can be either some kind of machine
readable API, maybe REST and Hypermedia driven, or it can be a real user interface, perhaps
based on HTML5 and JavaScript.

The interesting point here is that a SCS is in fact a standalone application. It contains
everything, from user interface to database, just everything that is needed to fulfill the
requirements of its bounded context.

== User interface integration patterns

Now, we have a small set of SCS that form our solution. How can a real user work with these
components? How does he login? How does he navigate? How does he perform some use cases? The answer
is simple. Instead of composing the systems at API level, we compose them at user interface
level. We need to build a Portal!

[ditaa,userinterfaceaggregation]
----
+------------------------------------------------------------------------------+
| Portal HTML Page                                                             |
|                                                                              |
|    +-------------------------------+    +-------------------------------+    |
|    | Part of SCS #1                |    | Other Part of SCS #1          |    |
|    +-------------------------------+    +-------------------------------+    |
|                                                                              |
|    +--------------------------------------------------------------------+    |
|    | Part of SCS #2                                                     |    |
|    |                                                                    |    |
|    |                                                                    |    |
|    |                                                                    |    |
|    |                                                                    |    |
|    +--------------------------------------------------------------------+    |
|                                                                              |
+------------------------------------------------------------------------------+
----

But how to we build a portal? Years ago we had a thing called Java Portlet API. Java Portlets became not
very popular, mostly due to the fact that they required a heavy weight Portal Server and most of the
time they became a user interface nightmare, as the Portlet API was very limited in its abilities.

Today, I wouldn't use a Portal Server. The portal for our SCS would be a simple application, delivering
some HTML templates and adding the composition logic. User interface composition can basically be done at two points:

 * Server side (HTTPd, NGINX)
 * Client side (Browser, JavaScript)

In the example above, we would use https://en.wikipedia.org/wiki/Server_Side_Includes[Server Side Includes] or SSI
to perform page composition. SSI is available for Apache HTTPd and NGINX. The Portal HTML templates comes with the
layout framework and special SSI directives for the parts that need to he included from our SCS. The SSI processor
now processes the SSI directives before the final HTML code is sent to the client.

After the final HTML is rendered in the browser, we might decide to update some parts of the site. This can be done
by using client side composition with some plain old AJAX. Using this technique, we can save server bandwith and greatly
increase user experience. Even if the user has disabled JavaScript in the browser, this wouldn't be an issue. In this case
we can always switch back to server side page composition.

== Common issues

 * State Management with and without Cookies
 * Global stylesheets
 * Search
 * Other display technologies (Android, IOS)

== Conclusion

