{"version":3,"sources":["../../../src/core/ticker/Ticker.js"],"names":["TICK","Ticker","_emitter","_requestId","_maxElapsedMS","autoStart","deltaTime","elapsedMS","TARGET_FPMS","lastTime","speed","started","_tick","time","update","listeners","requestAnimationFrame","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","start","add","fn","context","on","addOnce","once","remove","off","stop","currentTime","emit","fps","minFPMS","Math","min","max"],"mappings":"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","file":"Ticker.js","sourcesContent":["import settings from '../settings';\nimport EventEmitter from 'eventemitter3';\n\n// Internal event used by composed emitter\nconst TICK = 'tick';\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * This class is composed around an EventEmitter object to add listeners\n * meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary,\n * e.g. When the ticker is started and the emitter has listeners.\n *\n * @class\n * @memberof PIXI.ticker\n */\nexport default class Ticker\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        /**\n         * Internal emitter used to fire 'tick' event\n         * @private\n         */\n        this._emitter = new EventEmitter();\n\n        /**\n         * Internal current frame request ID\n         * @private\n         */\n        this._requestId = null;\n\n        /**\n         * Internal value managed by minFPS property setter and getter.\n         * This is the maximum allowed milliseconds between updates.\n         * @private\n         */\n        this._maxElapsedMS = 100;\n\n        /**\n         * Whether or not this ticker should invoke the method\n         * {@link PIXI.ticker.Ticker#start} automatically\n         * when a listener is added.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.autoStart = false;\n\n        /**\n         * Scalar time value from last frame to this frame.\n         * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}\n         * and is scaled with {@link PIXI.ticker.Ticker#speed}.\n         * **Note:** The cap may be exceeded by scaling.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.deltaTime = 1;\n\n        /**\n         * Time elapsed in milliseconds from last frame to this frame.\n         * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}\n         * is based, this value is neither capped nor scaled.\n         * If the platform supports DOMHighResTimeStamp,\n         * this value will have a precision of 1 µs.\n         *\n         * @member {number}\n         * @default 1 / TARGET_FPMS\n         */\n        this.elapsedMS = 1 / settings.TARGET_FPMS; // default to target frame time\n\n        /**\n         * The last time {@link PIXI.ticker.Ticker#update} was invoked.\n         * This value is also reset internally outside of invoking\n         * update, but only when a new animation frame is requested.\n         * If the platform supports DOMHighResTimeStamp,\n         * this value will have a precision of 1 µs.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.lastTime = 0;\n\n        /**\n         * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.\n         * @example\n         * // Scales ticker.deltaTime to what would be\n         * // the equivalent of approximately 120 FPS\n         * ticker.speed = 2;\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.speed = 1;\n\n        /**\n         * Whether or not this ticker has been started.\n         * `true` if {@link PIXI.ticker.Ticker#start} has been called.\n         * `false` if {@link PIXI.ticker.Ticker#stop} has been called.\n         * While `false`, this value may change to `true` in the\n         * event of {@link PIXI.ticker.Ticker#autoStart} being `true`\n         * and a listener is added.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.started = false;\n\n        /**\n         * Internal tick method bound to ticker instance.\n         * This is because in early 2015, Function.bind\n         * is still 60% slower in high performance scenarios.\n         * Also separating frame requests from update method\n         * so listeners may be called at any time and with\n         * any animation API, just invoke ticker.update(time).\n         *\n         * @private\n         * @param {number} time - Time since last tick.\n         */\n        this._tick = (time) =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._emitter.listeners(TICK, true))\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     *\n     * @private\n     */\n    _requestIfNeeded()\n    {\n        if (this._requestId === null && this._emitter.listeners(TICK, true))\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /**\n     * Conditionally cancels a pending animation frame.\n     *\n     * @private\n     */\n    _cancelIfNeeded()\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     *\n     * @private\n     */\n    _startIfPossible()\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Calls {@link module:eventemitter3.EventEmitter#on} internally for the\n     * internal 'tick' event. It checks if the emitter has listeners,\n     * and if so it requests a new animation frame at this point.\n     *\n     * @param {Function} fn - The listener function to be added for updates\n     * @param {Function} [context] - The listener context\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    add(fn, context)\n    {\n        this._emitter.on(TICK, fn, context);\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Calls {@link module:eventemitter3.EventEmitter#once} internally for the\n     * internal 'tick' event. It checks if the emitter has listeners,\n     * and if so it requests a new animation frame at this point.\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} [context] - The listener context\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    addOnce(fn, context)\n    {\n        this._emitter.once(TICK, fn, context);\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.\n     * It checks if the emitter has listeners for 'tick' event.\n     * If it does, then it cancels the animation frame.\n     *\n     * @param {Function} [fn] - The listener function to be removed\n     * @param {Function} [context] - The listener context to be removed\n     * @returns {PIXI.ticker.Ticker} This instance of a ticker\n     */\n    remove(fn, context)\n    {\n        this._emitter.off(TICK, fn, context);\n\n        if (!this._emitter.listeners(TICK, true))\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * Starts the ticker. If the ticker has listeners\n     * a new animation frame is requested at this point.\n     */\n    start()\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /**\n     * Stops the ticker. If the ticker has requested\n     * an animation frame it is canceled at this point.\n     */\n    stop()\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /**\n     * Triggers an update. An update entails setting the\n     * current {@link PIXI.ticker.Ticker#elapsedMS},\n     * the current {@link PIXI.ticker.Ticker#deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link PIXI.ticker.Ticker#lastTime}\n     * with the value of currentTime that was provided.\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     *\n     * @param {number} [currentTime=performance.now()] - the current time of execution\n     */\n    update(currentTime = performance.now())\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            this.deltaTime = elapsedMS * settings.TARGET_FPMS * this.speed;\n\n            // Invoke listeners added to internal emitter\n            this._emitter.emit(TICK, this.deltaTime);\n        }\n        else\n        {\n            this.deltaTime = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link PIXI.ticker.Ticker#speed}, which is specific\n     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.\n     *\n     * @memberof PIXI.ticker.Ticker#\n     * @readonly\n     */\n    get FPS()\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link PIXI.ticker.Ticker#update}.\n     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},\n     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `PIXI.settings.TARGET_FPMS * 1000`.\n     *\n     * @memberof PIXI.ticker.Ticker#\n     * @default 10\n     */\n    get minFPS()\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    /**\n     * Sets the min fps.\n     *\n     * @param {number} fps - value to set.\n     */\n    set minFPS(fps)\n    {\n        // Clamp: 0 to TARGET_FPMS\n        const minFPMS = Math.min(Math.max(0, fps) / 1000, settings.TARGET_FPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n}\n"]}