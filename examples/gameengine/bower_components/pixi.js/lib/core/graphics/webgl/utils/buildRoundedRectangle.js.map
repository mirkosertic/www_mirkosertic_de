{"version":3,"sources":["../../../../../src/core/graphics/webgl/utils/buildRoundedRectangle.js"],"names":["buildRoundedRectangle","graphicsData","webGLData","rrectData","shape","x","y","width","height","radius","recPoints","push","quadraticBezierCurve","fill","color","fillColor","alpha","fillAlpha","r","g","b","verts","points","indices","vecPos","length","triangles","i","j","lineWidth","tempPoints","fromX","fromY","cpX","cpY","toX","toY","out","n","xa","ya","xb","yb","getPt","n1","n2","perc","diff"],"mappings":"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","file":"buildRoundedRectangle.js","sourcesContent":["import earcut from 'earcut';\nimport buildLine from './buildLine';\nimport { hex2rgb } from '../../../utils';\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n */\nexport default function buildRoundedRectangle(graphicsData, webGLData)\n{\n    const rrectData = graphicsData.shape;\n    const x = rrectData.x;\n    const y = rrectData.y;\n    const width = rrectData.width;\n    const height = rrectData.height;\n\n    const radius = rrectData.radius;\n\n    const recPoints = [];\n\n    recPoints.push(x, y + radius);\n    quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);\n    quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);\n    quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);\n    quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);\n\n    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n    // TODO - fix this properly, this is not very elegant.. but it works for now.\n\n    if (graphicsData.fill)\n    {\n        const color = hex2rgb(graphicsData.fillColor);\n        const alpha = graphicsData.fillAlpha;\n\n        const r = color[0] * alpha;\n        const g = color[1] * alpha;\n        const b = color[2] * alpha;\n\n        const verts = webGLData.points;\n        const indices = webGLData.indices;\n\n        const vecPos = verts.length / 6;\n\n        const triangles = earcut(recPoints, null, 2);\n\n        for (let i = 0, j = triangles.length; i < j; i += 3)\n        {\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i + 1] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n        }\n\n        for (let i = 0, j = recPoints.length; i < j; i++)\n        {\n            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);\n        }\n    }\n\n    if (graphicsData.lineWidth)\n    {\n        const tempPoints = graphicsData.points;\n\n        graphicsData.points = recPoints;\n\n        buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out = [])\n{\n    const n = 20;\n    const points = out;\n\n    let xa = 0;\n    let ya = 0;\n    let xb = 0;\n    let yb = 0;\n    let x = 0;\n    let y = 0;\n\n    function getPt(n1, n2, perc)\n    {\n        const diff = n2 - n1;\n\n        return n1 + (diff * perc);\n    }\n\n    for (let i = 0, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt(fromX, cpX, j);\n        ya = getPt(fromY, cpY, j);\n        xb = getPt(cpX, toX, j);\n        yb = getPt(cpY, toY, j);\n\n        // The Black Dot\n        x = getPt(xa, xb, j);\n        y = getPt(ya, yb, j);\n\n        points.push(x, y);\n    }\n\n    return points;\n}\n"]}