{"version":3,"sources":["../../src/prepare/BasePrepare.js"],"names":["core","SharedTicker","ticker","shared","settings","UPLOADS_PER_FRAME","BasePrepare","renderer","limiter","uploadHookHelper","queue","addHooks","uploadHooks","completes","ticking","delayedTick","prepareItems","register","findText","drawText","findTextStyle","calculateTextStyle","upload","item","done","add","length","push","addOnce","tick","setTimeout","beginFrame","allowedToUpload","uploaded","i","len","shift","slice","addHook","uploadHook","Container","children","destroy","remove","helper","Text","updateText","TextStyle","font","getFontStyle","fontPropertiesCache","calculateFontProperties","indexOf","style","texture","_texture","baseTexture"],"mappings":"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","file":"BasePrepare.js","sourcesContent":["import * as core from '../core';\nimport CountLimiter from './limiters/CountLimiter';\nconst SharedTicker = core.ticker.shared;\n\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\ncore.settings.UPLOADS_PER_FRAME = 4;\n\n/**\n * The prepare manager provides functionality to upload content to the GPU. BasePrepare handles\n * basic queuing functionality and is extended by {@link PIXI.prepare.WebGLPrepare} and {@link PIXI.prepare.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @abstract\n * @class\n * @memberof PIXI\n */\nexport default class BasePrepare\n{\n    /**\n     * @param {PIXI.SystemRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * The limiter to be used to control how quickly items are prepared.\n         * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}\n         */\n        this.limiter = new CountLimiter(core.settings.UPLOADS_PER_FRAME);\n\n        /**\n         * Reference to the renderer.\n         * @type {PIXI.SystemRenderer}\n         * @protected\n         */\n        this.renderer = renderer;\n\n        /**\n         * The only real difference between CanvasPrepare and WebGLPrepare is what they pass\n         * to upload hooks. That different parameter is stored here.\n         * @type {PIXI.prepare.CanvasPrepare|PIXI.WebGLRenderer}\n         * @protected\n         */\n        this.uploadHookHelper = null;\n\n        /**\n         * Collection of items to uploads at once.\n         * @type {Array<*>}\n         * @private\n         */\n        this.queue = [];\n\n        /**\n         * Collection of additional hooks for finding assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.addHooks = [];\n\n        /**\n         * Collection of additional hooks for processing assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.uploadHooks = [];\n\n        /**\n         * Callback to call after completed.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.completes = [];\n\n        /**\n         * If prepare is ticking (running).\n         * @type {boolean}\n         * @private\n         */\n        this.ticking = false;\n\n        /**\n         * 'bound' call for prepareItems().\n         * @type {Function}\n         * @private\n         */\n        this.delayedTick = () =>\n        {\n            // unlikely, but in case we were destroyed between tick() and delayedTick()\n            if (!this.queue)\n            {\n                return;\n            }\n            this.prepareItems();\n        };\n\n        this.register(findText, drawText);\n        this.register(findTextStyle, calculateTextStyle);\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU.\n     *\n     * @param {Function|PIXI.DisplayObject|PIXI.Container} item - Either\n     *        the container or display object to search for items to upload or\n     *        the callback function, if items have been added using `prepare.add`.\n     * @param {Function} [done] - Optional callback when all queued uploads have completed\n     */\n    upload(item, done)\n    {\n        if (typeof item === 'function')\n        {\n            done = item;\n            item = null;\n        }\n\n        // If a display object, search for items\n        // that we could upload\n        if (item)\n        {\n            this.add(item);\n        }\n\n        // Get the items for upload from the display\n        if (this.queue.length)\n        {\n            if (done)\n            {\n                this.completes.push(done);\n            }\n\n            if (!this.ticking)\n            {\n                this.ticking = true;\n                SharedTicker.addOnce(this.tick, this);\n            }\n        }\n        else if (done)\n        {\n            done();\n        }\n    }\n\n    /**\n     * Handle tick update\n     *\n     * @private\n     */\n    tick()\n    {\n        setTimeout(this.delayedTick, 0);\n    }\n\n    /**\n     * Actually prepare items. This is handled outside of the tick because it will take a while\n     * and we do NOT want to block the current animation frame from rendering.\n     *\n     * @private\n     */\n    prepareItems()\n    {\n        this.limiter.beginFrame();\n        // Upload the graphics\n        while (this.queue.length && this.limiter.allowedToUpload())\n        {\n            const item = this.queue[0];\n            let uploaded = false;\n\n            for (let i = 0, len = this.uploadHooks.length; i < len; i++)\n            {\n                if (this.uploadHooks[i](this.uploadHookHelper, item))\n                {\n                    this.queue.shift();\n                    uploaded = true;\n                    break;\n                }\n            }\n\n            if (!uploaded)\n            {\n                this.queue.shift();\n            }\n        }\n\n        // We're finished\n        if (!this.queue.length)\n        {\n            this.ticking = false;\n\n            const completes = this.completes.slice(0);\n\n            this.completes.length = 0;\n\n            for (let i = 0, len = completes.length; i < len; i++)\n            {\n                completes[i]();\n            }\n        }\n        else\n        {\n            // if we are not finished, on the next rAF do this again\n            SharedTicker.addOnce(this.tick, this);\n        }\n    }\n\n    /**\n     * Adds hooks for finding and uploading items.\n     *\n     * @param {Function} [addHook] - Function call that takes two parameters: `item:*, queue:Array`\n              function must return `true` if it was able to add item to the queue.\n     * @param {Function} [uploadHook] - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n     *        function must return `true` if it was able to handle upload of item.\n     * @return {PIXI.CanvasPrepare} Instance of plugin for chaining.\n     */\n    register(addHook, uploadHook)\n    {\n        if (addHook)\n        {\n            this.addHooks.push(addHook);\n        }\n\n        if (uploadHook)\n        {\n            this.uploadHooks.push(uploadHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Manually add an item to the uploading queue.\n     *\n     * @param {PIXI.DisplayObject|PIXI.Container|*} item - Object to add to the queue\n     * @return {PIXI.CanvasPrepare} Instance of plugin for chaining.\n     */\n    add(item)\n    {\n        // Add additional hooks for finding elements on special\n        // types of objects that\n        for (let i = 0, len = this.addHooks.length; i < len; i++)\n        {\n            if (this.addHooks[i](item, this.queue))\n            {\n                break;\n            }\n        }\n\n        // Get childen recursively\n        if (item instanceof core.Container)\n        {\n            for (let i = item.children.length - 1; i >= 0; i--)\n            {\n                this.add(item.children[i]);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Destroys the plugin, don't use after this.\n     *\n     */\n    destroy()\n    {\n        if (this.ticking)\n        {\n            SharedTicker.remove(this.tick, this);\n        }\n        this.ticking = false;\n        this.addHooks = null;\n        this.uploadHooks = null;\n        this.renderer = null;\n        this.completes = null;\n        this.queue = null;\n        this.limiter = null;\n        this.uploadHookHelper = null;\n    }\n\n}\n\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction drawText(helper, item)\n{\n    if (item instanceof core.Text)\n    {\n        // updating text will return early if it is not dirty\n        item.updateText(true);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction calculateTextStyle(helper, item)\n{\n    if (item instanceof core.TextStyle)\n    {\n        const font = core.Text.getFontStyle(item);\n\n        if (!core.Text.fontPropertiesCache[font])\n        {\n            core.Text.calculateFontProperties(font);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\nfunction findText(item, queue)\n{\n    if (item instanceof core.Text)\n    {\n        // push the text style to prepare it - this can be really expensive\n        if (queue.indexOf(item.style) === -1)\n        {\n            queue.push(item.style);\n        }\n        // also push the text object so that we can render it (to canvas/texture) if needed\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n        // also push the Text's texture for upload to GPU\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue)\n{\n    if (item instanceof core.TextStyle)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n"]}