{"version":3,"sources":["../../src/extras/TilingSprite.js"],"names":["core","tempPoint","Point","TilingSprite","texture","width","height","tileTransform","TransformStatic","_width","_height","_canvasPattern","uvTransform","transform","pluginName","_onTextureUpdate","_texture","_renderWebGL","renderer","valid","updateLocalTransform","update","setObjectRenderer","plugins","render","_renderCanvas","baseTexture","hasLoaded","context","worldTransform","resolution","baseTextureResolution","modX","tilePosition","x","tileScale","_frame","modY","y","tempCanvas","CanvasRenderTarget","tint","cachedTint","tintedTexture","getTintedTexture","drawImage","source","createPattern","canvas","globalAlpha","worldAlpha","setTransform","a","b","c","d","tx","ty","scale","translate","anchor","setBlendMode","blendMode","fillStyle","fillRect","_calculateBounds","minX","_anchor","_x","minY","_y","maxX","maxY","_bounds","addFrame","getLocalBounds","rect","children","length","_localBoundsRect","Rectangle","getRectangle","call","containsPoint","point","applyInverse","x1","y1","destroy","from","Texture","fromFrame","frameId","utils","TextureCache","Error","fromImage","imageId","crossorigin","scaleMode","clampMargin","value","copy","position","Sprite"],"mappings":"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","file":"TilingSprite.js","sourcesContent":["import * as core from '../core';\nimport CanvasTinter from '../core/sprites/canvas/CanvasTinter';\nimport { default as TextureTransform } from './TextureTransform';\n\nconst tempPoint = new core.Point();\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n */\nexport default class TilingSprite extends core.Sprite\n{\n    /**\n     * @param {PIXI.Texture} texture - the texture of the tiling sprite\n     * @param {number} [width=100] - the width of the tiling sprite\n     * @param {number} [height=100] - the height of the tiling sprite\n     */\n    constructor(texture, width = 100, height = 100)\n    {\n        super(texture);\n\n        /**\n         * Tile transform\n         *\n         * @member {PIXI.TransformStatic}\n         */\n        this.tileTransform = new core.TransformStatic();\n\n        // /// private\n\n        /**\n         * The with of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._width = width;\n\n        /**\n         * The height of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._height = height;\n\n        /**\n         * Canvas pattern\n         *\n         * @type {CanvasPattern}\n         * @private\n         */\n        this._canvasPattern = null;\n\n        /**\n         * transform that is applied to UV to get the texture coords\n         *\n         * @member {PIXI.extras.TextureTransform}\n         */\n        this.uvTransform = texture.transform || new TextureTransform(texture);\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' method.\n         *\n         * @member {string}\n         * @default 'tilingSprite'\n         */\n        this.pluginName = 'tilingSprite';\n    }\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     *\n     * @default 0.5\n     * @member {number}\n     * @memberof PIXI.TilingSprite\n     */\n    get clampMargin()\n    {\n        return this.uvTransform.clampMargin;\n    }\n\n    /**\n     * setter for clampMargin\n     *\n     * @param {number} value assigned value\n     */\n    set clampMargin(value)\n    {\n        this.uvTransform.clampMargin = value;\n        this.uvTransform.update(true);\n    }\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     * @memberof PIXI.DisplayObject#\n     */\n    get tileScale()\n    {\n        return this.tileTransform.scale;\n    }\n\n    /**\n     * Copies the point to the scale of the tiled image.\n     *\n     * @param {PIXI.Point|PIXI.ObservablePoint} value - The value to set to.\n     */\n    set tileScale(value)\n    {\n        this.tileTransform.scale.copy(value);\n    }\n\n    /**\n     * The offset of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     * @memberof PIXI.TilingSprite#\n     */\n    get tilePosition()\n    {\n        return this.tileTransform.position;\n    }\n\n    /**\n     * Copies the point to the position of the tiled image.\n     *\n     * @param {PIXI.Point|PIXI.ObservablePoint} value - The value to set to.\n     */\n    set tilePosition(value)\n    {\n        this.tileTransform.position.copy(value);\n    }\n\n    /**\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        if (this.uvTransform)\n        {\n            this.uvTransform.texture = this._texture;\n        }\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer)\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        this.tileTransform.updateLocalTransform();\n        this.uvTransform.update();\n\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n     */\n    _renderCanvas(renderer)\n    {\n        const texture = this._texture;\n\n        if (!texture.baseTexture.hasLoaded)\n        {\n            return;\n        }\n\n        const context = renderer.context;\n        const transform = this.worldTransform;\n        const resolution = renderer.resolution;\n        const baseTexture = texture.baseTexture;\n        const baseTextureResolution = texture.baseTexture.resolution;\n        const modX = (this.tilePosition.x / this.tileScale.x) % texture._frame.width;\n        const modY = (this.tilePosition.y / this.tileScale.y) % texture._frame.height;\n\n        // create a nice shiny pattern!\n        // TODO this needs to be refreshed if texture changes..\n        if (!this._canvasPattern)\n        {\n            // cut an object from a spritesheet..\n            const tempCanvas = new core.CanvasRenderTarget(texture._frame.width,\n                                                        texture._frame.height,\n                                                        baseTextureResolution);\n\n            // Tint the tiling sprite\n            if (this.tint !== 0xFFFFFF)\n            {\n                if (this.cachedTint !== this.tint)\n                {\n                    this.cachedTint = this.tint;\n\n                    this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);\n                }\n                tempCanvas.context.drawImage(this.tintedTexture, 0, 0);\n            }\n            else\n            {\n                tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x, -texture._frame.y);\n            }\n            this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n        }\n\n        // set context state..\n        context.globalAlpha = this.worldAlpha;\n        context.setTransform(transform.a * resolution,\n                           transform.b * resolution,\n                           transform.c * resolution,\n                           transform.d * resolution,\n                           transform.tx * resolution,\n                           transform.ty * resolution);\n\n        // TODO - this should be rolled into the setTransform above..\n        context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n\n        context.translate(modX + (this.anchor.x * -this._width),\n                          modY + (this.anchor.y * -this._height));\n\n        renderer.setBlendMode(this.blendMode);\n\n        // fill the pattern!\n        context.fillStyle = this._canvasPattern;\n        context.fillRect(-modX,\n                         -modY,\n                         this._width / this.tileScale.x * baseTextureResolution,\n                         this._height / this.tileScale.y * baseTextureResolution);\n    }\n\n    /**\n     * Updates the bounds of the tiling sprite.\n     *\n     * @private\n     */\n    _calculateBounds()\n    {\n        const minX = this._width * -this._anchor._x;\n        const minY = this._height * -this._anchor._y;\n        const maxX = this._width * (1 - this._anchor._x);\n        const maxY = this._height * (1 - this._anchor._y);\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     *\n     * @param {PIXI.Rectangle} rect - The output rectangle.\n     * @return {PIXI.Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._x);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new core.Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._bounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Checks if a point is inside this tiling sprite.\n     *\n     * @param {PIXI.Point} point - the point to check\n     * @return {boolean} Whether or not the sprite contains the point.\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this.anchor._x;\n\n        if (tempPoint.x > x1 && tempPoint.x < x1 + width)\n        {\n            const y1 = -height * this.anchor._y;\n\n            if (tempPoint.y > y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this tiling sprite\n     *\n     */\n    destroy()\n    {\n        super.destroy();\n\n        this.tileTransform = null;\n        this.uvTransform = null;\n    }\n\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static from(source, width, height)\n    {\n        return new TilingSprite(core.Texture.from(source), width, height);\n    }\n\n    /**\n     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n     * The frame ids are created when a Texture packer file has been loaded\n     *\n     * @static\n     * @param {string} frameId - The frame Id of the texture in the cache\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n     */\n    static fromFrame(frameId, width, height)\n    {\n        const texture = core.utils.TextureCache[frameId];\n\n        if (!texture)\n        {\n            throw new Error(`The frameId \"${frameId}\" does not exist in the texture cache ${this}`);\n        }\n\n        return new TilingSprite(texture, width, height);\n    }\n\n    /**\n     * Helper function that creates a sprite that will contain a texture based on an image url\n     * If the image is not in the texture cache it will be loaded\n     *\n     * @static\n     * @param {string} imageId - The image url of the texture\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,\n     *  see {@link PIXI.SCALE_MODES} for possible values\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n     */\n    static fromImage(imageId, width, height, crossorigin, scaleMode)\n    {\n        return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.extras.TilingSprite#\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Sets the width.\n     *\n     * @param {number} value - The value to set to.\n     */\n    set width(value)\n    {\n        this._width = value;\n    }\n\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.extras.TilingSprite#\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Sets the width.\n     *\n     * @param {number} value - The value to set to.\n     */\n    set height(value)\n    {\n        this._height = value;\n    }\n}\n"]}